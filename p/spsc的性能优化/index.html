<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="SPSC的代码里哪些地方可以优化？"><title>SPSC的性能优化</title><link rel=canonical href=https://miyan.site/p/spsc%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/><link rel=stylesheet href=/scss/style.min.f4e976c31b00797a057d2b73e28d253271789dfe857d4ffbe42ab065b83775a1.css><meta property='og:title' content="SPSC的性能优化"><meta property='og:description' content="SPSC的代码里哪些地方可以优化？"><meta property='og:url' content='https://miyan.site/p/spsc%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/'><meta property='og:site_name' content='miyan的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2025-12-08T00:00:00+00:00'><meta property='article:modified_time' content='2025-12-21T15:34:04+08:00'><meta name=twitter:title content="SPSC的性能优化"><meta name=twitter:description content="SPSC的代码里哪些地方可以优化？"><link rel="shortcut icon" href=/favicon.svg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"dark")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b3b280c13e06dfac.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>miyan的博客</a></h1><h2 class=site-description>可以什么都不会，不能不会躺下来感受幸福</h2></div></header><ol class=menu-social><li><a href=https://github.com/miyanyan target=_blank title=GitHub rel=me><!doctype html><svg t="1713884694671" class="icon" viewBox="0 0 1024 1024" p-id="9399" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M64 512c0 195.2 124.8 361.6 300.8 422.4 22.4 6.4 19.2-9.6 19.2-22.4v-76.8c-134.4 16-140.8-73.6-150.4-89.6-19.2-32-60.8-38.4-48-54.4 32-16 64 3.2 99.2 57.6 25.6 38.4 76.8 32 105.6 25.6 6.4-22.4 19.2-44.8 35.2-60.8C281.6 691.2 224 604.8 224 502.4c0-48 16-96 48-131.2-22.4-60.8.0-115.2 3.2-121.6 57.6-6.4 118.4 41.6 124.8 44.8 32-9.6 70.4-12.8 112-12.8s80 6.4 112 12.8c12.8-9.6 67.2-48 121.6-44.8 3.2 6.4 25.6 57.6 6.4 118.4 32 38.4 48 83.2 48 131.2.0 102.4-57.6 188.8-201.6 214.4 22.4 22.4 38.4 54.4 38.4 92.8v112c0 9.6.0 19.2 16 19.2C832 876.8 960 710.4 960 512c0-246.4-201.6-448-448-448S64 265.6 64 512z" fill="#040000" p-id="9400"/></svg></a></li><li><a href=https://leetcode.cn/u/miyanyanyan/ target=_blank title=Leetcode rel=me><!doctype html><svg t="1713884461345" class="icon" viewBox="0 0 1024 1024" p-id="4333" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M701.28 766.86a58.9 58.9.0 0183.1 83.52l-102.24 102c-94.3 94.16-248 95.52-344 3.16-.56-.52-43.26-42.4-184.12-180.54-93.72-92-103.06-238.94-14.88-333.36l164.44-176C391.12 172 552.46 161.68 652.54 242.6l149.34 120.78a58.92 58.92.0 01-74 91.76L578.54 334.36c-52.34-42.34-144-36.52-189.06 11.84l-164.44 176c-42.94 46-38.22 120 11.26 168.54l183.26 179.7c49.86 48 130.48 47.3 179.42-1.58z" fill="#FFA116" p-id="4334"/><path d="M452.94 664.7a58.96 58.96.0 010-118h434a58.96 58.96.0 010 118z" fill="#B3B3B3" p-id="4335"/><path d="M534.22 18.68a58.9 58.9.0 1186 80.56L225.1 522.28c-42.92 46-38.22 120 11.24 168.54l182.46 178.9A58.92 58.92.0 01336.46 954L154.06 775.08c-93.7-92-103.04-238.94-14.84-333.36z" p-id="4336"/></svg></a></li><li><a href=https://www.zhihu.com/people/li-xiao-yan-98-60 target=_blank title=Zhihu rel=me><svg viewBox="51.20000000000002 51.2 921.6 921.6" width="2500" height="2500"><path fill="#06F" d="M656.906 724.29l47.422-33.725h52.69V344.9h-143.32v346.726h35.83z"/><path fill="#06F" d="M849.92 51.2H174.08c-67.866.0-122.88 55.014-122.88 122.88v675.84c0 67.866 55.014 122.88 122.88 122.88h675.84c67.866.0 122.88-55.014 122.88-122.88V174.08c0-67.866-55.014-122.88-122.88-122.88zM495.662 803.348l-101.171-157.05 44.267-31.616 67.451 98.007c-.005.0 23.179 37.995-10.547 90.66zm38.994-276.1v25.292H408.197C357.612 876.068 204.8 807.045 204.8 807.045 344.965 697.18 347.597 552.54 347.597 552.54H208.492c0-57.958 52.162-56.914 52.162-56.914h93.793V343.87h-50.585c-18.965 85.366-99.062 81.152-99.062 81.152s32.67-50.585 54.8-137c22.128-86.421 89.574-76.929 89.574-76.929-20.02 35.83-29.507 76.928-29.507 76.928H485.12c40.049.0 37.94 25.293 37.94 25.293v29.512H411.355v152.806h91.684c33.725.0 31.616 31.616 31.616 31.616zM819.2 747.5H716.974l-88.52 55.848-8.427-55.848h-64.292V288.015H819.2V747.5z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/%E9%93%BE%E6%8E%A5/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#背景>背景</a></li><li><a href=#stdqueue--stdmutex>std::queue + std::mutex</a></li><li><a href=#优化点1-使用环形缓冲区替代stdqueue使用atomic操作替代锁>优化点1: 使用环形缓冲区替代std::queue，使用atomic操作替代锁</a></li><li><a href=#优化点2-对齐cacheline防止false-sharing>优化点2: 对齐cacheline防止false sharing</a></li><li><a href=#优化点3-缓存读写位置>优化点3: 缓存读写位置</a></li><li><a href=#优化点4-利用无符号数的回绕特性和2的幂次mask减少分支判断和取模操作>优化点4: 利用无符号数的回绕特性和2的幂次mask减少分支判断和取模操作</a></li><li><a href=#写在最后>写在最后</a></li><li><a href=#更新>更新</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/c++/>C++</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/spsc%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>SPSC的性能优化</a></h2><h3 class=article-subtitle>SPSC的代码里哪些地方可以优化？</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-12-08T00:00:00Z>2025-12-08</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 12 分钟</time></div></footer></div></header><section class=article-content><h2 id=背景>背景</h2><p>SPSC是Single Producer Single Consumer的简称，即单生产者单消费者模型。在多线程编程中，SPSC模型是一种常见的模型，它要求一个线程只负责生产数据，另一个线程只负责消费数据。</p><p>在引入优化点之前，我们要先达成几点共识：</p><ul><li>SPSC一般情况下限制最大的buffer大小，一开始就分配足够的空间，我们假定非特殊情况buffer是不会被填满的，如果buffer经常被填满那你的系统就有问题了。当然像<a class=link href=https://github.com/cameron314/readerwriterqueue target=_blank rel=noopener>readerwriterqueue</a>就是支持扩容的，引入内存分配就变得复杂起来，先不考虑。</li><li>生产者只push，消费者只pop</li><li>以非阻塞版本的push和pop来进行比较优化</li></ul><h2 id=stdqueue--stdmutex>std::queue + std::mutex</h2><p>首先引入基础版本的SPSC模型，即使用std::queue和std::mutex。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mutex&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SPSC_Mutex</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC_Mutex</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>push</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lk</span><span class=p>(</span><span class=n>m_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>m_queue</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>lk</span><span class=p>(</span><span class=n>m_mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>m_queue</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>value</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>m_queue</span><span class=p>.</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>m_queue</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>m_mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>queue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>m_queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=优化点1-使用环形缓冲区替代stdqueue使用atomic操作替代锁>优化点1: 使用环形缓冲区替代std::queue，使用atomic操作替代锁</h2><p>基于上文buffer可以设置最大大小的假设，我们可以考虑使用环形缓冲区来替代std::queue。环形缓冲区的介绍参考<a class=link href=https://en.wikipedia.org/wiki/Circular_buffer target=_blank rel=noopener>wiki:Circular_buffer</a>，基于此：</p><ul><li>判空，empty = (readIndex == writeIndex)</li><li>判满，这里可以牺牲一个槽位(slot)防止判空和判满的歧义，full = ((writeIndex + 1) % capacity == readIndex)</li><li>剩余空间，size = (writeIndex - readIndex + capacity) % capacity</li><li>push, writeIndex = (writeIndex + pushSize) % capacity，注意，由于牺牲了一个槽位，所以这里的pushSize不能超过<strong>剩余空间-1</strong></li><li>pop, readIndex = (readIndex + popSize) % capacity</li></ul><p>基于环形缓冲区的特点，我们可以考虑使用atomic操作来替代锁。</p><ul><li>生产者只修改writeIndex，消费者只修改readIndex，因此可以使用atomic操作来保证线程安全。</li><li>对于不同的操作，可以采用不同的内存序:<ul><li>push, 由于writeIndex只有生产者修改，因此可以使用std::memory_order_relaxed来进行读取，使用std::memory_order_release来进行写入。</li><li>pop, 由于readIndex只有消费者修改，因此可以使用std::memory_order_relaxed来进行读取，使用std::memory_order_release来进行写入。</li><li>push/pop里读取对方的index时，使用std::memory_order_acquire来进行读取。</li><li>判空/判满/剩余空间，生产者消费者线程都可以调用，全部采用std::memory_order_acquire来进行读取。</li></ul></li></ul><p>C++ 的六种内存序（从弱到强）：C++11 定义了 6 种内存序，按照约束强度从弱到强排序，性能开销通常也随之增加。</p><ol><li>std::memory_order_relaxed (松散序)<ul><li>约束：最弱。只保证原子性（操作不可分割），不保证任何顺序。</li><li>行为：不同线程看到的变量更新顺序可能完全不同。</li><li>场景：统计计数器（如 std::shared_ptr 的引用计数增加）。只需保证“不撕裂写入”，不在乎谁先谁后。</li></ul></li><li>std::memory_order_consume (消费序)<ul><li>约束：比 Acquire 弱。只保证有数据依赖关系的指令不乱序。</li><li>现状：极难正确使用，编译器支持糟糕（通常直接提升为 Acquire）。C++ 标准委员会正在修订它。</li><li>建议：不要使用，直接用 Acquire 代替。</li></ul></li><li>std::memory_order_acquire (获取序)<ul><li>操作：Load（读取）。</li><li>约束：后面的读写不能排到前面。</li><li>场景：互斥锁的加锁（Lock）、读取信号量、消费者读取 tail 指针。</li></ul></li><li>std::memory_order_release (释放序)<ul><li>操作：Store（写入）。</li><li>约束：前面的读写不能排到后面。</li><li>场景：互斥锁的解锁（Unlock）、释放信号量、生产者更新 head 指针。</li></ul></li><li>std::memory_order_acq_rel (获取释放序)<ul><li>操作：Read-Modify-Write (如 fetch_add, exchange, compare_exchange)。</li><li>约束：兼具 Acquire 和 Release 的双重效果。既是输入的屏障，也是输出的屏障。</li><li>场景：原子操作（如 fetch_add, exchange, compare_exchange）。CAS 操作。多个线程同时读写同一个原子变量进行同步时（例如实现一个自旋锁）。</li></ul></li><li>std::memory_order_seq_cst (顺序一致性)<ul><li>约束：最强，也是 C++ 原子操作的默认选项。</li><li>行为：包含 Acquire/Release 的所有语义。全局全序：所有线程看到的“所有 Seq_Cst 操作的顺序”是一模一样的。</li><li>代价：在 x86 上通常也是廉价的（类似 Acquire/Release），但在 ARM/PowerPC 等弱内存模型架构上，需要插入很重的内存屏障指令（Memory Fence），严重影响性能。</li><li>场景：新手默认使用。逻辑极其复杂，Acquire/Release 搞不定时。需要保证全局单一顺序时。</li></ul></li></ol><p>最终实现如下(folly的实现)：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SPSC1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>SPSC1</span><span class=p>(</span><span class=n>size_t</span> <span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>m_capacity</span><span class=p>(</span><span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>m_buffer</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=n>m_capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>m_buffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>SPSC1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to destruct anything that may still exist in our queue.
</span></span></span><span class=line><span class=cl>        <span class=c1>// (No real synchronization needed at destructor time: only one
</span></span></span><span class=line><span class=cl>        <span class=c1>// thread can be doing this.)
</span></span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_trivially_destructible</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>endIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>!=</span> <span class=n>endIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>m_buffer</span><span class=p>[</span><span class=n>readIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>readIndex</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>readIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>free</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SPSC1</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC1</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC1</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC1</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC1</span><span class=p>(</span><span class=n>SPSC1</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC1</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>SPSC1</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>push</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentWriteIndex</span><span class=p>])</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>currentWriteIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextWriteIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=n>currentReadIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextReadIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextReadIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isEmpty</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>               <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isFull</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span> <span class=n>nextWriteIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>writeIndex</span> <span class=o>&gt;=</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>return</span> <span class=n>writeIndex</span> <span class=o>-</span> <span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=n>readIndex</span> <span class=o>+</span> <span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>getAvailableSpace</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>writeIndex</span><span class=p>,</span> <span class=n>readIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>AtomicIndex</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>m_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>const</span> <span class=n>m_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_consumerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>writeIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_producerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=优化点2-对齐cacheline防止false-sharing>优化点2: 对齐cacheline防止false sharing</h2><p><a class=link href=https://en.wikipedia.org/wiki/False_sharing target=_blank rel=noopener>wiki:False_sharing</a></p><p>如果你看了<a class=link href=https://github.com/facebook/folly/blob/main/folly/ProducerConsumerQueue.h#L176 target=_blank rel=noopener>ProducerConsumerQueue</a>的实现，你可能已经注意到了hardware_destructive_interference_size，它在folly里的定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#if defined(__cpp_lib_hardware_interference_size)
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//  GCC unconditionally warns about uses of the std&#39;s interference-size
</span></span></span><span class=line><span class=cl><span class=c1>//  constants, on the basis that their uses in public ABIs is likely broken:
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//    its value can vary between compiler versions or with different ‘-mtune’
</span></span></span><span class=line><span class=cl><span class=c1>//    or ‘-mcpu’ flags; if this use is part of a public ABI, change it to
</span></span></span><span class=line><span class=cl><span class=c1>//    instead use a constant variable you define
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//  For now, these remain theoretical concerns in the expected scenario, where
</span></span></span><span class=line><span class=cl><span class=c1>//  all of the application is built together with the same compiler options.
</span></span></span><span class=line><span class=cl><span class=n>FOLLY_PUSH_WARNING</span>
</span></span><span class=line><span class=cl><span class=nf>FOLLY_GCC_DISABLE_WARNING</span><span class=p>(</span><span class=s>&#34;-Winterference-size&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>hardware_constructive_interference_size</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>hardware_constructive_interference_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>hardware_destructive_interference_size</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>hardware_destructive_interference_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FOLLY_POP_WARNING</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//  Memory locations within the same cache line are subject to destructive
</span></span></span><span class=line><span class=cl><span class=c1>//  interference, also known as false sharing, which is when concurrent
</span></span></span><span class=line><span class=cl><span class=c1>//  accesses to these different memory locations from different cores, where at
</span></span></span><span class=line><span class=cl><span class=c1>//  least one of the concurrent accesses is or involves a store operation,
</span></span></span><span class=line><span class=cl><span class=c1>//  induce contention and harm performance.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//  Microbenchmarks indicate that pairs of cache lines also see destructive
</span></span></span><span class=line><span class=cl><span class=c1>//  interference under heavy use of atomic operations, as observed for atomic
</span></span></span><span class=line><span class=cl><span class=c1>//  increment on Sandy Bridge.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//  We assume a cache line size of 64, so we use a cache line pair size of 128
</span></span></span><span class=line><span class=cl><span class=c1>//  to avoid destructive interference.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//  mimic: std::hardware_destructive_interference_size, C++17
</span></span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>hardware_destructive_interference_size</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=n>kIsArchArm</span> <span class=o>||</span> <span class=n>kIsArchS390X</span><span class=p>)</span> <span class=o>?</span> <span class=mi>64</span> <span class=o>:</span> <span class=mi>128</span><span class=p>;</span>
</span></span></code></pre></div><p>这里关于cacheline的大小，不同的设备架构可能有不同的大小，大部分情况下为64，folly在c++17以上支持std::hardware_destructive_interference_size时以此为默认值，否则以128为默认值。std::hardware_destructive_interference_size的值又得视情况而定，比如MSVC的源码里就直接写成64：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#if defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64)
</span></span></span><span class=line><span class=cl><span class=n>_EXPORT_STD</span> <span class=kr>inline</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>hardware_constructive_interference_size</span> <span class=o>=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>_EXPORT_STD</span> <span class=kr>inline</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>hardware_destructive_interference_size</span>  <span class=o>=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else </span><span class=c1>// ^^^ supported hardware / unsupported hardware vvv
</span></span></span><span class=line><span class=cl><span class=cp>#error Unsupported architecture
</span></span></span><span class=line><span class=cl><span class=cp>#endif </span><span class=c1>// ^^^ unsupported hardware ^^^
</span></span></span></code></pre></div><p>gcc/clang的情况则各式各样：https://github.com/llvm/llvm-project/pull/89446#issuecomment-2070649367</p><p>关于cacheline，folly的注释里还提及相邻的cacheline也可能对性能产生影像，Intel CPU可能会加载相邻的cacheline</p><blockquote><p>Intel&rsquo;s optimization manual does describe the L2 spatial prefetcher in SnB-family CPUs. Yes, it tries to complete 128B-aligned pairs of 64B lines, when there&rsquo;s spare memory bandwidth (off-core request tracking slots) when the first line is getting pulled in.</p></blockquote><p>这里提到的是SnB-family CPUs，stackoverflow上有人提到确实有这种优化，但我在自己的intel和amd电脑上未观察到cacheline在128时比64有明显提升的情况。</p><p>参考：</p><ul><li><a class=link href=https://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes target=_blank rel=noopener>https://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes</a></li><li><a class=link href=https://stackoverflow.com/questions/39680206/understanding-stdhardware-destructive-interference-size-and-stdhardware-cons target=_blank rel=noopener>https://stackoverflow.com/questions/39680206/understanding-stdhardware-destructive-interference-size-and-stdhardware-cons</a></li></ul><p>综上，cacheline应该怎么选择？我建议直接使用std::hardware_destructive_interference_size的大小，除非你的benchmark能明显看到性能提升，目前的绝大多数开源库也都是这么做的:</p><ul><li>folly，c++17以上使用标准库，否则默认128</li><li><a class=link href=https://github.com/rigtorp/SPSCQueue/blob/1053918dbd251fbff69b24ef27fa5d51c29ec2af/include/rigtorp/SPSCQueue.h#L210-L215 target=_blank rel=noopener>SPSCQueue</a>，c++17以上使用标准库，否则默认64</li><li><a class=link href=https://github.com/cameron314/readerwriterqueue/blob/master/readerwriterqueue.h target=_blank rel=noopener>readerwriterqueue</a>，使用宏来控制，默认64</li><li><a class=link href=https://github.com/max0x7ba/atomic_queue/blob/master/include/atomic_queue/defs.h target=_blank rel=noopener>atomic_queue</a>，分不同的架构设置不同的大小，默认64</li></ul><p>最终基于cacheline的优化代码，只需要设置读写索引的对齐大小为cacheline大小：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;new&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// This block handles a GCC-specific warning about ABI stability.
</span></span></span><span class=line><span class=cl><span class=cp>#if defined(__GNUC__) &amp;&amp; !defined(__clang__)
</span></span></span><span class=line><span class=cl><span class=cp>#    pragma GCC diagnostic push
</span></span></span><span class=line><span class=cl><span class=cp>#    pragma GCC diagnostic ignored &#34;-Winterference-size&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if defined(__cpp_lib_hardware_interference_size)
</span></span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>kCacheLineSize</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>hardware_destructive_interference_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=k>constexpr</span> <span class=n>size_t</span> <span class=n>kCacheLineSize</span> <span class=o>=</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if defined(__GNUC__) &amp;&amp; !defined(__clang__)
</span></span></span><span class=line><span class=cl><span class=cp>#    pragma GCC diagnostic pop
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>以上为kCacheLineSize的定义，后面出现的所有<code>kCacheLineSize</code>都是指这个值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SPSC2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>SPSC2</span><span class=p>(</span><span class=n>size_t</span> <span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>m_capacity</span><span class=p>(</span><span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>m_buffer</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=n>m_capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>m_buffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>SPSC2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to destruct anything that may still exist in our queue.
</span></span></span><span class=line><span class=cl>        <span class=c1>// (No real synchronization needed at destructor time: only one
</span></span></span><span class=line><span class=cl>        <span class=c1>// thread can be doing this.)
</span></span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_trivially_destructible</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>endIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>!=</span> <span class=n>endIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>m_buffer</span><span class=p>[</span><span class=n>readIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>readIndex</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>readIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>free</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SPSC2</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC2</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC2</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC2</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC2</span><span class=p>(</span><span class=n>SPSC2</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC2</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>SPSC2</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>push</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentWriteIndex</span><span class=p>])</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>currentWriteIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextWriteIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=n>currentReadIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextReadIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextReadIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isEmpty</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>               <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isFull</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span> <span class=n>nextWriteIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>writeIndex</span> <span class=o>&gt;=</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>return</span> <span class=n>writeIndex</span> <span class=o>-</span> <span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=n>readIndex</span> <span class=o>+</span> <span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>getAvailableSpace</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>writeIndex</span><span class=p>,</span> <span class=n>readIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>AtomicIndex</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>m_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>const</span> <span class=n>m_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_consumerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>writeIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_producerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=优化点3-缓存读写位置>优化点3: 缓存读写位置</h2><p>参考：https://rigtorp.se/ringbuffer/</p><p>缓存读写位置的优化，可以减少生产者和消费者线程的交互，提高缓存命中率。</p><ul><li>生产者维护自己的写位置，缓存的读位置，每次push计算可用空间，只有空间不足的情况下才会访问消费者更改的读位置，否则空间足够完全可以直接push</li><li>消费者维护自己的读位置，缓存的写位置，每次pop计算已用空间，只有空间不足的情况下才会访问生产者更改的写位置，否则空间足够完全可以直接pop</li></ul><p>最终的基于索引缓存的成员变量</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SPSC3</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>SPSC3</span><span class=p>(</span><span class=n>size_t</span> <span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>m_capacity</span><span class=p>(</span><span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>m_buffer</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=n>m_capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>m_buffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>SPSC3</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to destruct anything that may still exist in our queue.
</span></span></span><span class=line><span class=cl>        <span class=c1>// (No real synchronization needed at destructor time: only one
</span></span></span><span class=line><span class=cl>        <span class=c1>// thread can be doing this.)
</span></span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_trivially_destructible</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>endIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>!=</span> <span class=n>endIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>m_buffer</span><span class=p>[</span><span class=n>readIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>readIndex</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>readIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>free</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SPSC3</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC3</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC3</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC3</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC3</span><span class=p>(</span><span class=n>SPSC3</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC3</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>SPSC3</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>push</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// if not enough space, refresh the cached read index and check again
</span></span></span><span class=line><span class=cl>            <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// not enough space
</span></span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentWriteIndex</span><span class=p>])</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>currentWriteIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextWriteIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>  <span class=c1>// not enough samples
</span></span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>m_buffer</span><span class=p>[</span><span class=n>currentReadIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=n>currentReadIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextReadIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextReadIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isEmpty</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>               <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isFull</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>nextWriteIndex</span> <span class=o>&gt;=</span> <span class=n>m_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span> <span class=n>nextWriteIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>writeIndex</span> <span class=o>&gt;=</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>return</span> <span class=n>writeIndex</span> <span class=o>-</span> <span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=n>readIndex</span> <span class=o>+</span> <span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>getAvailableSpace</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>writeIndex</span><span class=p>,</span> <span class=n>readIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>AtomicIndex</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>m_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>const</span> <span class=n>m_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>writeIndexCache</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_consumerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>writeIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>readIndexCache</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_producerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>实测下来，相比于没有索引缓存的版本，吞吐量有明显提升。</p><h2 id=优化点4-利用无符号数的回绕特性和2的幂次mask减少分支判断和取模操作>优化点4: 利用无符号数的回绕特性和2的幂次mask减少分支判断和取模操作</h2><p>可以发现，folly版本使用了一个空槽来防止判空和判满的歧义，并且每次更新读写索引时，需要添加一个if来判断是否将索引变回0。同理，如果每次push或pop是批量操作，也需要添加if判断或者取模操作。</p><p>我们可以利用size_t的回绕特性，以及将buffer大小设置为2的幂次来减少分支判断和取模操作：</p><ul><li>读写索引一直累加，直到超过size_t最大值，然后回绕到0</li><li>设置capacity为2的幂次，这样可以用位运算来代替取模操作</li><li>当前大小：writeIndex - readIndex，利用size_t的回绕特性，可以直接计算当前大小</li><li>判空：readIndex == writeIndex</li><li>判满：writeIndex - readIndex == capacity，可以发现不需要空一个槽位了！这里基于的假设是，申请的buffer的最大值是永远不可能超过size_t的最大值的，申请不到这么大的内存。</li><li>获取真实的物理索引即对应到buffer里的索引，pyhsicalIndex = index & (capacity - 1)</li><li>push/pop，直接累加读写索引，更新的读写数据位置则使用上一条的物理索引计算方法定位</li></ul><p>但是，实际测试下来只看到了一丢丢的提升，毕竟按照之前的写法，分支判断大部分情况下都不会进去，cpu的分支预测起作用了？或者是内存瓶颈这一点点计算优化影响不大。</p><p>最终写出c++20版本的spsc队列：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SPSC4</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>SPSC4</span><span class=p>(</span><span class=n>size_t</span> <span class=n>minCapacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>:</span> <span class=n>m_capacity</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>bit_ceil</span><span class=p>(</span><span class=n>minCapacity</span> <span class=o>&lt;=</span> <span class=mi>1</span> <span class=o>?</span> <span class=mi>2</span> <span class=o>:</span> <span class=n>minCapacity</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>m_mask</span><span class=p>(</span><span class=n>m_capacity</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>,</span> <span class=n>m_buffer</span><span class=p>(</span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>T</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>malloc</span><span class=p>(</span><span class=n>m_capacity</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>T</span><span class=p>))))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>m_buffer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>std</span><span class=o>::</span><span class=n>bad_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>SPSC4</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to destruct anything that may still exist in our queue.
</span></span></span><span class=line><span class=cl>        <span class=c1>// (No real synchronization needed at destructor time: only one
</span></span></span><span class=line><span class=cl>        <span class=c1>// thread can be doing this.)
</span></span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>std</span><span class=o>::</span><span class=n>is_trivially_destructible</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>size_t</span> <span class=n>endIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>readIndex</span> <span class=o>!=</span> <span class=n>endIndex</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>m_buffer</span><span class=p>[</span><span class=n>readIndex</span> <span class=o>&amp;</span> <span class=n>m_mask</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>readIndex</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>free</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SPSC4</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC4</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC4</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SPSC4</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC4</span><span class=p>(</span><span class=n>SPSC4</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SPSC4</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>SPSC4</span><span class=o>&amp;&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>template</span><span class=o>&lt;</span><span class=k>class</span><span class=err>... </span><span class=nc>Args</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>push</span><span class=p>(</span><span class=n>Args</span><span class=o>&amp;&amp;</span><span class=p>...</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentWriteIndex</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// if not enough space, refresh the cached read index and check again
</span></span></span><span class=line><span class=cl>            <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>availableSpace</span> <span class=o>=</span> <span class=n>getAvailableSpace</span><span class=p>(</span><span class=n>currentWriteIndex</span><span class=p>,</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>readIndexCache</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>availableSpace</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span> <span class=c1>// not enough space
</span></span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>physicalWriteIndex</span> <span class=o>=</span> <span class=n>currentWriteIndex</span> <span class=o>&amp;</span> <span class=n>m_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>new</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>physicalWriteIndex</span><span class=p>])</span> <span class=n>T</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>Args</span><span class=o>&gt;</span><span class=p>(</span><span class=n>args</span><span class=p>)...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextWriteIndex</span> <span class=o>=</span> <span class=n>currentWriteIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextWriteIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>pop</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>currentReadIndex</span> <span class=o>=</span> <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span> <span class=o>=</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>availableSamples</span> <span class=o>=</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>m_consumerData</span><span class=p>.</span><span class=n>writeIndexCache</span><span class=p>,</span> <span class=n>currentReadIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>availableSamples</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>  <span class=c1>// not enough samples
</span></span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>physicalReadIndex</span> <span class=o>=</span> <span class=n>currentReadIndex</span> <span class=o>&amp;</span> <span class=n>m_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>m_buffer</span><span class=p>[</span><span class=n>physicalReadIndex</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>m_buffer</span><span class=p>[</span><span class=n>physicalReadIndex</span><span class=p>].</span><span class=o>~</span><span class=n>T</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>nextReadIndex</span> <span class=o>=</span> <span class=n>currentReadIndex</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>nextReadIndex</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>capacity</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>m_capacity</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isEmpty</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>==</span>
</span></span><span class=line><span class=cl>               <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>isFull</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// use the warp-around logic to check if the buffer is full
</span></span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>m_producerData</span><span class=p>.</span><span class=n>writeIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>-</span>
</span></span><span class=line><span class=cl>                <span class=n>m_consumerData</span><span class=p>.</span><span class=n>readIndex</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>))</span> <span class=o>==</span> <span class=n>m_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>writeIndex</span> <span class=o>-</span> <span class=n>readIndex</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=nf>getAvailableSpace</span><span class=p>(</span><span class=n>size_t</span> <span class=n>writeIndex</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>readIndex</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_capacity</span> <span class=o>-</span> <span class=n>calculateSize</span><span class=p>(</span><span class=n>writeIndex</span><span class=p>,</span> <span class=n>readIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>using</span> <span class=n>AtomicIndex</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>size_t</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>m_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>size_t</span> <span class=n>m_mask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span><span class=o>*</span> <span class=k>const</span> <span class=n>m_buffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>readIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>writeIndexCache</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_consumerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=n>kCacheLineSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>AtomicIndex</span> <span class=n>writeIndex</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>size_t</span> <span class=n>readIndexCache</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=n>m_producerData</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=写在最后>写在最后</h2><p>可以看到目前的开源库基本都没有提供批量操作，<a class=link href=https://github.com/cameron314/concurrentqueue target=_blank rel=noopener>concurrentqueue</a>倒是提供了bulk操作。</p><p>那怎么才能批量操作呢？</p><ul><li>把上述的每次操作的<strong>索引+1</strong>改成<strong>索引+n</strong>，这样就可以批量操作了</li><li>对于push和pop，都要处理回绕问题，需要分成两块数据操作</li></ul><p>除此之外，还可以使用Claim的方式</p><ul><li>Claim: 生产者问队列：“给我预留 N 个位置，把指针给我”。</li><li>Write: 生产者直接往这些指针里写数据（Zero-Copy，直接构造）。</li><li>Commit: 生产者告诉队列：“这 N 个写完了，更新索引”。</li></ul><h2 id=更新>更新</h2><p>发现<a class=link href="https://www.youtube.com/watch?v=K3P_Lmq6pw0" target=_blank rel=noopener>cppcon2023 spsc</a>的视频已经讲过了，对应的<a class=link href=https://github.com/CharlesFrasch/cppcon2023 target=_blank rel=noopener>github代码</a>。<br>而且总结的条款顺序和我一样，不过作者最后放的测试结果，我的机器上没发现他写的Fifi4a比其他的开源库有明显的性能提升，毕竟这些spsc的代码都大差不差的。</p><p>我的测试代码见<a class=link href=https://github.com/miyanyan/spsc target=_blank rel=noopener>miyanyan/spsc</a></p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>最后更新于 2025-12-21 15:34:04</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/c-%E7%BC%96%E8%AF%91%E6%9C%9F%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D/><div class=article-details><h2 class=article-title>C++ 编译期获取类名</h2></div></a></article><article><a href=/p/%E4%BD%BF%E7%94%A8stdmake_unique_for_overwrite%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAchar%E6%95%B0%E7%BB%84%E5%BD%93%E7%BC%93%E5%86%B2%E5%8C%BA/><div class=article-details><h2 class=article-title>使用std::make_unique_for_overwrite创建一个char数组当缓冲区</h2></div></a></article><article><a href=/p/c-stdfunction-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><div class=article-details><h2 class=article-title>C++ std::function 实现原理</h2></div></a></article><article><a href=/p/pybind11%E4%BD%BF%E7%94%A82-%E7%BC%96%E5%86%99c-%E7%B1%BB%E5%B9%B6%E5%AF%BC%E5%87%BA%E4%B8%BApyd/><div class=article-details><h2 class=article-title>pybind11使用(2) 编写C++类并导出为pyd</h2></div></a></article><article><a href=/p/pybind11%E4%BD%BF%E7%94%A81-cmake--vcpkg-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/><div class=article-details><h2 class=article-title>pybind11使用(1) cmake + vcpkg 环境配置以及一些坑</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=miyanyan/miyanyan.github.io data-repo-id=R_kgDOOg52Pg data-category=Announcements data-category-id=DIC_kwDOOg52Ps4CpjZF data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 miyan的博客</section><section class=powerby>网站总访客数：<span id=busuanzi_value_site_uv>Loading</span><br>网站总访问量：<span id=busuanzi_value_site_pv>Loading</span><br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.32.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><div id=particles-js></div><script src=/background/particles.min.js></script><script>particlesJS.load("particles-js","/background/particlesjs-config.json",function(){console.log("particles.js loaded - callback")})</script><style>#particles-js{position:fixed;top:0;left:0;width:100%;z-index:-1}</style><script defer src=https://cn.vercount.one/js></script><style>@font-face{font-family:maplemono2;src:url(https://miyan.site/font/MapleMono2.ttf)format('truetype')}:root{--base-font-family:'MapleMono2';--code-font-family:'MapleMono2'}</style></body></html>