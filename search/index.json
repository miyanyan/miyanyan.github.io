[{"content":"笔者偶尔会给vcpkg提交一些包的更新，这里记录下遇到的问题，与大家分享，如能起到一点点帮助那我就更开心了。\n首先是github提pr的基本流程，这里假设大家都已经知道了，此为前提。\n更新包 更新版本 以fmt为例，我们这次的目的要更新fmt的版本号到11.0.2\n在vcpkg的路径ports文件夹下找到要更新的包，为例，那么我们就要找到文件夹vcpkg/ports/fmt\n在这个文件夹下有两个主要文件，也就是我们要修改的地方\nvcpkg.json 这个文件对fmt包进行了基本的描述，因为我们主要关注版本的更新，所以我们主要看参数version和port-version\nversion对应版本号，把它更新为11.0.2; port-version为当前版本的修改号，一般的，当我们更新版本时要去掉port-version(port-version将在下一节修复问题时用到)\n好了，更新完后应该是这样子的\n{ \u0026#34;name\u0026#34;: \u0026#34;fmt\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;11.0.2\u0026#34;, # \u0026lt;--- 更新了这里的版本号。VVV 下面没有port-version \u0026#34;description\u0026#34;: \u0026#34;{fmt} is an open-source formatting library providing a fast and safe alternative to C stdio and C++ iostreams.\u0026#34;, \u0026#34;homepage\u0026#34;: \u0026#34;https://github.com/fmtlib/fmt\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;vcpkg-cmake\u0026#34;, \u0026#34;host\u0026#34;: true }, { \u0026#34;name\u0026#34;: \u0026#34;vcpkg-cmake-config\u0026#34;, \u0026#34;host\u0026#34;: true } ] } portfile.cmake 这个文件对fmt怎么用cmake构建进行了描述，因为我们主要关注版本的更新，所以我们只看文件里的vcpkg_from_github函数，这个函数里有两个要改的变量\nREF vcpkg是根据REF的值去判断下载github上的哪个版本的release去编译的，如果你发现REF的值是\u0026quot;${VERSION}\u0026quot;， 那么这里一般就不需要改了，否则你需要把它改成版本号(当然，你提pr的时候就会发现vcpkg的官方人员会提醒你使用\u0026quot;${VERSION}\u0026quot;，减少一处改动何乐而不为呢哈哈) SHA512 这个值是github上release的压缩包的哈希值，用于校验下载的文件是否正确。那么怎么得到这个哈希值呢? 在vcpkg的根目录下执行vcpkg install fmt， 等待一段时间，vcpkg会报错，在报错信息里找到这两行：\n... Expected hash: xxxxx Actual hash: 47ff6d289dcc22681eea6da465b0348172921e7cafff8fd57a1540d3232cc6b53250a4625c954ee0944c87963b17680ecbc3ea123e43c2c822efe0dc6fa6cef3 ... 看到没，这个Actual hash的值就是你要修改的SHA512的值了，复制过来。\n在vcpkg的根目录下再次执行vcpkg install fmt，如果没有报错那么恭喜你，更新包的流程就完成了一大半了！\n好了，更新完后应该是这样子的\nvcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO fmtlib/fmt REF \u0026#34;${VERSION}\u0026#34; # \u0026lt;--- 无需修改 SHA512 47ff6d289dcc22681eea6da465b0348172921e7cafff8fd57a1540d3232cc6b53250a4625c954ee0944c87963b17680ecbc3ea123e43c2c822efe0dc6fa6cef3 # \u0026lt;--- 必须修改哈希值 HEAD_REF master ) 将刚才的修改git commit\n在vcpkg的根目录下执行vcpkg x-add-version --all，这会修改vcpkg用于记录的数据库，对应两个文件\nversions/f-/fmt.json versions/baseline.json 当然，这两个文件的改动是自动修改的，再次git commit 将git修改提交到vcpkg的pull request中\n修复当前版本的问题 很多时候不是简简单单更新个版本号就能正确更新的，某些包的更新可能会导致依赖于此包的其他包编译报错，某些包的更新可能会引入自己的新bug等等\u0026hellip;\n我们还是以fmt为例，当fmt从v10升级到v11后，有很多大的改动， 比如要使用fmt的join函数，必须要显式的#include \u0026lt;fmt/ranges.h\u0026gt;，这会导致libtorch编译报错，我们需要修改libtorch相关的报错文件，在其文件中#include \u0026lt;fmt/ranges.h\u0026gt;\n那么要怎么做呢，我们的核心思想就是对这次修复形成一个commit，利用git的patch机制生成一个patch文件，最终在构建时将这个patch文件引入进来，从而解决编译报错等问题。\n参考https://github.com/Microsoft/vcpkg-docs/blob/main/vcpkg/examples/patching.md\n为libtorch创建git本地仓库\n执行vcpkg install libtorch，此时由于fmt的更新会导致编译报错，没错就是缺少#include \u0026lt;fmt/ranges.h\u0026gt;导致的报错。我们找到vcpkg下载下来的libtorch的源文件目录\nvcpkg/buildtrees/libtorch/src这个目录下存储着libtorch每次的下载缓存，一般的我们选最新的那个目录并进入该目录 执行git init .初始化本地仓库 执行git add .把libtorch的所有原文件加入暂存区 执行git commit -m \u0026quot;temp\u0026quot;把所有原文件提交 修改libtorch的编译报错问题 这里我们已经知道了要显式的#include \u0026lt;fmt/ranges.h\u0026gt;，直接找到对应的文件修改吧！\n为修改完的文件生成patch\n执行git status可以看到我们修改的文件，确认修改无误 执行git diff --ignore-space-at-eol | out-file -enc ascii ..\\..\\..\\..\\ports\\libtorch\\fix-build-error-with-fmt11.patch即可把patch文件生成到vcpkg/ports/libtorch下， 这个文件长这样fix-build-error-with-fmt11.patch\n注意，vcpkg的官方人员会要求你文件用LF而不是CRLF，记得确定 在portfile.cmake文件中添加该patch\nvcpkg_from_github( # 其他参数... PATCHES fix-build-error-with-fmt11.patch # \u0026lt;-- 这里就是生成的patch文件了 ) 验证行patch是否能解决问题 再次执行vcpkg install libtorch，如果没有报错那么就是成功了！\n将vcpkg.json文件中的port-version号加1，如果没有port-version则说明当前的port-version号为0\n将刚才的修改git commit\n在vcpkg的根目录下执行vcpkg x-add-version --all，再次git commit\n将git修改提交到vcpkg的pull request中\n添加包 如果你已经知道了如何更新包，那么你肯定熟悉了vcpkg的目录结构，这里我们再复述一下，vcpkg目录下的ports/\u0026lt;your-port-name\u0026gt;主要包含两个文件：\nportfile.cmake: 如何用cmake编译 vcpkg.json: 这个包的依赖关系等描述 接下来我们以添加ucoro到vcpkg为例\n在ports文件夹下新建ucoro文件夹\n在ucoro文件夹下添加portfile.cmake和vcpkg.json两个文件。(我一般是找个就近的包把它的这俩文件copy过来)\n修改vcpkg.json文件内容，主要是名称、版本号、描述、网址、许可证、依赖\n修改portfile.cmake文件，一般的，我们把下面的每一个函数都调用一下总不会错\n如果是header-only的库，那么就在第一行添加set(VCPKG_BUILD_TYPE release)，这样不会有debug的文件目录生成，ucoro就是一个header-only的库，这里我加上了这一行。 使用vcpkg_from_github从github下载ucoro的release文件 使用vcpkg_cmake_configure传入项目编译的cmake参数 使用vcpkg_cmake_install调用cmake install命令安装库 使用vcpkg_cmake_config_fixup确保生成的cmake安装文件符合vcpkg的要求 使用vcpkg_fixup_pkgconfig修复 *.pc 文件中的通用路径 使用file(INSTALL \u0026quot;${SOURCE_PATH}/LICENSE_1_0.txt\u0026quot; DESTINATION \u0026quot;${CURRENT_PACKAGES_DIR}/share/${PORT}\u0026quot; RENAME copyright)复制ucoro的license到目标目录 好了，现在就和上面的更新包操作一样，使用vcpkg install ucoro直到vcpkg不再报错和警告即大功告成，最终的port.cmake文件如下，可以看到我还添加了一个cmake-install.patch文件，这是因为ucoro的cmake文件里没有写cmake install指令，当然cmake语法这里不做介绍。\nset(VCPKG_BUILD_TYPE release) # header-only vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO avplayer/ucoro REF \u0026#34;v${VERSION}\u0026#34; SHA512 c3436b436ef1ebb3d47a65db9603842293bdb6451bc6fb738a63d61a63b52901e223f46625d956303566dc52dfb38ffb2c6ce20016c18b444f9cb3e2e701e613 HEAD_REF main PATCHES cmake-install.patch ) vcpkg_cmake_configure( SOURCE_PATH \u0026#34;${SOURCE_PATH}\u0026#34; OPTIONS -DUCORO_BUILD_TESTING=OFF ) vcpkg_cmake_install() vcpkg_cmake_config_fixup() vcpkg_fixup_pkgconfig() file(INSTALL \u0026#34;${SOURCE_PATH}/LICENSE_1_0.txt\u0026#34; DESTINATION \u0026#34;${CURRENT_PACKAGES_DIR}/share/${PORT}\u0026#34; RENAME copyright) 和更新包的操作一样，git commit并提交pr吧！\n常见问题 有的包生成的.pc文件里有绝对路径，导致vcpkg的ci报错 使用vcpkg_fixup_pkgconfig()进行修复，如更新magic-enum时我发现之前的portfile.cmake里并未对pc文件进行修复\n某个包的当前版本的bug需要修复，如何添加patch 这个bug已经被修复了，只是没有更新到这个版本\n首先我们找到这个bug修复对应的commit，这里我们以更新fmt到11为例，在这个pr里我发现fmt的更新导致folly编译报错，具体原因忽略，这个编译报错被修复对应的commit为https://github.com/facebook/folly/commit/21e8dcd464ee46b2144a1e4d4c0e452355ae15f0，我们进入到这个commit对应的链接，可以看到修改的git diff。\n但是！咱们现在要的是一个可以用的patch文件，这里就需要加入一点github官方文档未提供的方法了(也许提供了但是我没找到？)，在这个commit链接后面加上.patch，即https://github.com/facebook/folly/commit/21e8dcd464ee46b2144a1e4d4c0e452355ae15f0.patch，可以发现现在是纯文本了，接下来还要在最后加上?full_index=1，按讨论区的说法，加上这个之后可以保证链接的稳定。\nYou have to add ?full_index=1 to the URL to get a full commit hash in the patch, otherwise the number of characters used to write the commit in the patch will grow as the project grows.\n参考https://github.com/orgs/community/discussions/46034#discussioncomment-4846112\npatch文件搞定了，接下来就是把这个链接放到vcpkg的portfile.cmake文件中，调用vcpkg_download_distfile把文件下载下来，\nvcpkg_download_distfile(FMT11_RANGE_PATCH # 这里给patch起个名称 URLS https://github.com/facebook/folly/commit/21e8dcd464ee46b2144a1e4d4c0e452355ae15f0.patch?full_index=1 FILENAME fmt11-range.patch SHA512 6a3afe361cd24b4f62b3aba625dfbbfb767c91f27fa45ed4604adc5ec3d574e571ece13eeda0d9d47b8a37166fc31b1ed7f58f120a35d35977085a08172de105 ) 并在vcpkg_from_github中设置这个文件为对应的patch。至此完成了拉取上游修改并添加为patch的操作。\nvcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO facebook/folly REF \u0026#34;v${VERSION}\u0026#34; SHA512 f129d4e530b5c8aaf4cbfb0c813e84ee911ec26e43fa01e6e1c9557501c605a8123d46d0c689b32eb5e5a57280968662a5fa370ede17af7526db59545e9a70db HEAD_REF main PATCHES disable-non-underscore-posix-names.patch fix-windows-minmax.patch fix-deps.patch disable-uninitialized-resize-on-new-stl.patch fix-unistd-include.patch fix-fmt11-cmake.patch ${FMT11_RANGE_PATCH} # 这里就是下载下来的patch ) 如何在vcpkg的ci检查中跳过某些检查 在更新fastdds时我遇到了fastdds在老版本的android上由于缺少依赖编译不过去的问题\n官方的回复也是说针对这种情况要在ci里跳过检查\nCI is instructed to skip many ports which required API level 24 for android\n主要修改的地方为文件scripts/ci.baseline.txt 在这个文件里添加希望跳过的检查：\nfastdds:arm-neon-android=fail fastdds:arm64-android=fail fastdds:x64-android=fail 在更新highifive时我遇到了highfive的feature在ci上通过了确被忽略的报错，报错信息为：\nD:\\a\\_work\\1\\s\\scripts\\azure-pipelines/../ci.feature.baseline.txt:954:1: error: highfive[core]:arm64-windows passed but was marked expected to be a cascaded failure D:\\a\\_work\\1\\s\\scripts\\azure-pipelines/../ci.feature.baseline.txt:954:1: error: highfive[core,eigen3]:arm64-windows passed but was marked expected to be a cascaded failure D:\\a\\_work\\1\\s\\scripts\\azure-pipelines/../ci.feature.baseline.txt:954:1: error: highfive[core,xtensor]:arm64-windows passed but was marked expected to be a cascaded failure D:\\a\\_work\\1\\s\\scripts\\azure-pipelines/../ci.feature.baseline.txt:954:1: error: highfive[core,boost]:arm64-windows passed but was marked expected to be a cascaded failure 这里的意思就是feature通过了但是被标记为了理应失败，对应修改的地方为文件scripts/ci.feature.baseline.txt:\nhighfive:arm64-uwp = cascade highfive:x64-uwp = cascade highfive[opencv]:arm64-windows = cascade 如何在vcpkg中更新boost 我最开始更新boost 1.87.0 时是傻乎乎的一个个的更新的，后来才发现官方有脚本的\u0026hellip;\u0026hellip;\n脚本路径为vcpkg/scripts/boost/generate-ports.ps1, 注意要使用PowerShell 6 或更高版本，否则会报错。\n","date":"2024-11-17T00:00:00Z","permalink":"https://miyan.site/p/%E5%A6%82%E4%BD%95%E7%BB%99vcpkg%E6%8F%90pr/","title":"如何给vcpkg提pr"},{"content":"背景 SPSC是Single Producer Single Consumer的简称，即单生产者单消费者模型。在多线程编程中，SPSC模型是一种常见的模型，它要求一个线程只负责生产数据，另一个线程只负责消费数据。\n在引入优化点之前，我们要先达成几点共识：\nSPSC一般情况下限制最大的buffer大小，一开始就分配足够的空间，我们假定非特殊情况buffer是不会被填满的，如果buffer经常被填满那你的系统就有问题了。当然像readerwriterqueue就是支持扩容的，引入内存分配就变得复杂起来，先不考虑。 生产者只push，消费者只pop 以非阻塞版本的push和pop来进行比较优化 std::queue + std::mutex 首先引入基础版本的SPSC模型，即使用std::queue和std::mutex。\n#include \u0026lt;queue\u0026gt; #include \u0026lt;atomic\u0026gt; #include \u0026lt;mutex\u0026gt; template\u0026lt;typename T\u0026gt; class SPSC_Mutex { public: SPSC_Mutex() = default; bool push(T\u0026amp;\u0026amp; value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m_mutex); m_queue.push(std::move(value)); return true; } bool pop(T\u0026amp; value) { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m_mutex); if (m_queue.empty()) { return false; } value = std::move(m_queue.front()); m_queue.pop(); return true; } private: std::mutex m_mutex; std::queue\u0026lt;T\u0026gt; m_queue; }; 优化点1: 使用环形缓冲区替代std::queue，使用atomic操作替代锁 基于上文buffer可以设置最大大小的假设，我们可以考虑使用环形缓冲区来替代std::queue。环形缓冲区的介绍参考wiki:Circular_buffer，基于此：\n判空，empty = (readIndex == writeIndex) 判满，这里可以牺牲一个槽位(slot)防止判空和判满的歧义，full = ((writeIndex + 1) % capacity == readIndex) 剩余空间，size = (writeIndex - readIndex + capacity) % capacity push, writeIndex = (writeIndex + pushSize) % capacity，注意，由于牺牲了一个槽位，所以这里的pushSize不能超过剩余空间-1 pop, readIndex = (readIndex + popSize) % capacity 基于环形缓冲区的特点，我们可以考虑使用atomic操作来替代锁。\n生产者只修改writeIndex，消费者只修改readIndex，因此可以使用atomic操作来保证线程安全。 对于不同的操作，可以采用不同的内存序: push, 由于writeIndex只有生产者修改，因此可以使用std::memory_order_relaxed来进行读取，使用std::memory_order_release来进行写入。 pop, 由于readIndex只有消费者修改，因此可以使用std::memory_order_relaxed来进行读取，使用std::memory_order_release来进行写入。 push/pop里读取对方的index时，使用std::memory_order_acquire来进行读取。 判空/判满/剩余空间，生产者消费者线程都可以调用，全部采用std::memory_order_acquire来进行读取。 C++ 的六种内存序（从弱到强）：C++11 定义了 6 种内存序，按照约束强度从弱到强排序，性能开销通常也随之增加。\nstd::memory_order_relaxed (松散序) 约束：最弱。只保证原子性（操作不可分割），不保证任何顺序。 行为：不同线程看到的变量更新顺序可能完全不同。 场景：统计计数器（如 std::shared_ptr 的引用计数增加）。只需保证“不撕裂写入”，不在乎谁先谁后。 std::memory_order_consume (消费序) 约束：比 Acquire 弱。只保证有数据依赖关系的指令不乱序。 现状：极难正确使用，编译器支持糟糕（通常直接提升为 Acquire）。C++ 标准委员会正在修订它。 建议：不要使用，直接用 Acquire 代替。 std::memory_order_acquire (获取序) 操作：Load（读取）。 约束：后面的读写不能排到前面。 场景：互斥锁的加锁（Lock）、读取信号量、消费者读取 tail 指针。 std::memory_order_release (释放序) 操作：Store（写入）。 约束：前面的读写不能排到后面。 场景：互斥锁的解锁（Unlock）、释放信号量、生产者更新 head 指针。 std::memory_order_acq_rel (获取释放序) 操作：Read-Modify-Write (如 fetch_add, exchange, compare_exchange)。 约束：兼具 Acquire 和 Release 的双重效果。既是输入的屏障，也是输出的屏障。 场景：原子操作（如 fetch_add, exchange, compare_exchange）。CAS 操作。多个线程同时读写同一个原子变量进行同步时（例如实现一个自旋锁）。 std::memory_order_seq_cst (顺序一致性) 约束：最强，也是 C++ 原子操作的默认选项。 行为：包含 Acquire/Release 的所有语义。全局全序：所有线程看到的“所有 Seq_Cst 操作的顺序”是一模一样的。 代价：在 x86 上通常也是廉价的（类似 Acquire/Release），但在 ARM/PowerPC 等弱内存模型架构上，需要插入很重的内存屏障指令（Memory Fence），严重影响性能。 场景：新手默认使用。逻辑极其复杂，Acquire/Release 搞不定时。需要保证全局单一顺序时。 最终实现如下(folly的实现)：\ntemplate\u0026lt;typename T\u0026gt; class SPSC1 { public: explicit SPSC1(size_t minCapacity) : m_capacity(minCapacity) , m_buffer(static_cast\u0026lt;T*\u0026gt;(std::malloc(m_capacity * sizeof(T)))) { if (!m_buffer) { throw std::bad_alloc(); } } ~SPSC1() { // We need to destruct anything that may still exist in our queue. // (No real synchronization needed at destructor time: only one // thread can be doing this.) if (!std::is_trivially_destructible\u0026lt;T\u0026gt;::value) { size_t readIndex = m_consumerData.readIndex; size_t endIndex = m_producerData.writeIndex; while (readIndex != endIndex) { m_buffer[readIndex].~T(); readIndex++; if (readIndex \u0026gt;= m_capacity) { readIndex = 0; } } } std::free(m_buffer); } SPSC1(const SPSC1\u0026amp;) = delete; SPSC1\u0026amp; operator=(const SPSC1\u0026amp;) = delete; SPSC1(SPSC1\u0026amp;\u0026amp;) = delete; SPSC1\u0026amp; operator=(SPSC1\u0026amp;\u0026amp;) = delete; template\u0026lt;class... Args\u0026gt; bool push(Args\u0026amp;\u0026amp;... args) { size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_relaxed); size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_acquire); size_t availableSpace = getAvailableSpace(currentWriteIndex, currentReadIndex); if (availableSpace \u0026lt; 1) { return false; } new (\u0026amp;m_buffer[currentWriteIndex]) T(std::forward\u0026lt;Args\u0026gt;(args)...); size_t nextWriteIndex = currentWriteIndex + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } m_producerData.writeIndex.store(nextWriteIndex, std::memory_order_release); return true; } bool pop(T\u0026amp; output) { size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_relaxed); size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_acquire); size_t availableSamples = calculateSize(currentWriteIndex, currentReadIndex); if (availableSamples \u0026lt; 1) { return false; } output = std::move(m_buffer[currentReadIndex]); m_buffer[currentReadIndex].~T(); size_t nextReadIndex = currentReadIndex + 1; if (nextReadIndex \u0026gt;= m_capacity) { nextReadIndex = 0; } m_consumerData.readIndex.store(nextReadIndex, std::memory_order_release); return true; } size_t capacity() const { return m_capacity - 1; } bool isEmpty() const { return m_producerData.writeIndex.load(std::memory_order_acquire) == m_consumerData.readIndex.load(std::memory_order_acquire); } bool isFull() const { auto nextWriteIndex = m_producerData.writeIndex.load(std::memory_order_acquire) + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } return m_consumerData.readIndex.load(std::memory_order_acquire) == nextWriteIndex; } private: size_t calculateSize(size_t writeIndex, size_t readIndex) const { if (writeIndex \u0026gt;= readIndex) return writeIndex - readIndex; return m_capacity - readIndex + writeIndex; } size_t getAvailableSpace(size_t writeIndex, size_t readIndex) const { return m_capacity - 1 - calculateSize(writeIndex, readIndex); } using AtomicIndex = std::atomic\u0026lt;size_t\u0026gt;; const size_t m_capacity; T* const m_buffer; struct { AtomicIndex readIndex = {0}; } m_consumerData; struct { AtomicIndex writeIndex = {0}; } m_producerData; }; 优化点2: 对齐cacheline防止false sharing wiki:False_sharing\n如果你看了ProducerConsumerQueue的实现，你可能已经注意到了hardware_destructive_interference_size，它在folly里的定义如下：\n#if defined(__cpp_lib_hardware_interference_size) // GCC unconditionally warns about uses of the std\u0026#39;s interference-size // constants, on the basis that their uses in public ABIs is likely broken: // // its value can vary between compiler versions or with different ‘-mtune’ // or ‘-mcpu’ flags; if this use is part of a public ABI, change it to // instead use a constant variable you define // // For now, these remain theoretical concerns in the expected scenario, where // all of the application is built together with the same compiler options. FOLLY_PUSH_WARNING FOLLY_GCC_DISABLE_WARNING(\u0026#34;-Winterference-size\u0026#34;) constexpr std::size_t hardware_constructive_interference_size = std::hardware_constructive_interference_size; constexpr std::size_t hardware_destructive_interference_size = std::hardware_destructive_interference_size; FOLLY_POP_WARNING #else // Memory locations within the same cache line are subject to destructive // interference, also known as false sharing, which is when concurrent // accesses to these different memory locations from different cores, where at // least one of the concurrent accesses is or involves a store operation, // induce contention and harm performance. // // Microbenchmarks indicate that pairs of cache lines also see destructive // interference under heavy use of atomic operations, as observed for atomic // increment on Sandy Bridge. // // We assume a cache line size of 64, so we use a cache line pair size of 128 // to avoid destructive interference. // // mimic: std::hardware_destructive_interference_size, C++17 constexpr std::size_t hardware_destructive_interference_size = (kIsArchArm || kIsArchS390X) ? 64 : 128; 这里关于cacheline的大小，不同的设备架构可能有不同的大小，大部分情况下为64，folly在c++17以上支持std::hardware_destructive_interference_size时以此为默认值，否则以128为默认值。std::hardware_destructive_interference_size的值又得视情况而定，比如MSVC的源码里就直接写成64：\n#if defined(_M_IX86) || defined(_M_X64) || defined(_M_ARM) || defined(_M_ARM64) _EXPORT_STD inline constexpr size_t hardware_constructive_interference_size = 64; _EXPORT_STD inline constexpr size_t hardware_destructive_interference_size = 64; #else // ^^^ supported hardware / unsupported hardware vvv #error Unsupported architecture #endif // ^^^ unsupported hardware ^^^ gcc/clang的情况则各式各样：https://github.com/llvm/llvm-project/pull/89446#issuecomment-2070649367\n关于cacheline，folly的注释里还提及相邻的cacheline也可能对性能产生影像，Intel CPU可能会加载相邻的cacheline\nIntel\u0026rsquo;s optimization manual does describe the L2 spatial prefetcher in SnB-family CPUs. Yes, it tries to complete 128B-aligned pairs of 64B lines, when there\u0026rsquo;s spare memory bandwidth (off-core request tracking slots) when the first line is getting pulled in.\n这里提到的是SnB-family CPUs，stackoverflow上有人提到确实有这种优化，但我在自己的intel和amd电脑上未观察到cacheline在128时比64有明显提升的情况。\n参考：\nhttps://stackoverflow.com/questions/72126606/should-the-cache-padding-size-of-x86-64-be-128-bytes https://stackoverflow.com/questions/39680206/understanding-stdhardware-destructive-interference-size-and-stdhardware-cons 综上，cacheline应该怎么选择？我建议直接使用std::hardware_destructive_interference_size的大小，除非你的benchmark能明显看到性能提升，目前的绝大多数开源库也都是这么做的:\nfolly，c++17以上使用标准库，否则默认128 SPSCQueue，c++17以上使用标准库，否则默认64 readerwriterqueue，使用宏来控制，默认64 atomic_queue，分不同的架构设置不同的大小，默认64 最终基于cacheline的优化代码，只需要设置读写索引的对齐大小为cacheline大小：\n#pragma once #include \u0026lt;new\u0026gt; // This block handles a GCC-specific warning about ABI stability. #if defined(__GNUC__) \u0026amp;\u0026amp; !defined(__clang__) # pragma GCC diagnostic push # pragma GCC diagnostic ignored \u0026#34;-Winterference-size\u0026#34; #endif #if defined(__cpp_lib_hardware_interference_size) inline constexpr size_t kCacheLineSize = std::hardware_destructive_interference_size; #else inline constexpr size_t kCacheLineSize = 64; #endif #if defined(__GNUC__) \u0026amp;\u0026amp; !defined(__clang__) # pragma GCC diagnostic pop #endif 以上为kCacheLineSize的定义，后面出现的所有kCacheLineSize都是指这个值。\ntemplate\u0026lt;typename T\u0026gt; class SPSC2 { public: explicit SPSC2(size_t minCapacity) : m_capacity(minCapacity) , m_buffer(static_cast\u0026lt;T*\u0026gt;(std::malloc(m_capacity * sizeof(T)))) { if (!m_buffer) { throw std::bad_alloc(); } } ~SPSC2() { // We need to destruct anything that may still exist in our queue. // (No real synchronization needed at destructor time: only one // thread can be doing this.) if (!std::is_trivially_destructible\u0026lt;T\u0026gt;::value) { size_t readIndex = m_consumerData.readIndex; size_t endIndex = m_producerData.writeIndex; while (readIndex != endIndex) { m_buffer[readIndex].~T(); readIndex++; if (readIndex \u0026gt;= m_capacity) { readIndex = 0; } } } std::free(m_buffer); } SPSC2(const SPSC2\u0026amp;) = delete; SPSC2\u0026amp; operator=(const SPSC2\u0026amp;) = delete; SPSC2(SPSC2\u0026amp;\u0026amp;) = delete; SPSC2\u0026amp; operator=(SPSC2\u0026amp;\u0026amp;) = delete; template\u0026lt;class... Args\u0026gt; bool push(Args\u0026amp;\u0026amp;... args) { size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_relaxed); size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_acquire); size_t availableSpace = getAvailableSpace(currentWriteIndex, currentReadIndex); if (availableSpace \u0026lt; 1) { return false; } new (\u0026amp;m_buffer[currentWriteIndex]) T(std::forward\u0026lt;Args\u0026gt;(args)...); size_t nextWriteIndex = currentWriteIndex + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } m_producerData.writeIndex.store(nextWriteIndex, std::memory_order_release); return true; } bool pop(T\u0026amp; output) { size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_relaxed); size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_acquire); size_t availableSamples = calculateSize(currentWriteIndex, currentReadIndex); if (availableSamples \u0026lt; 1) { return false; } output = std::move(m_buffer[currentReadIndex]); m_buffer[currentReadIndex].~T(); size_t nextReadIndex = currentReadIndex + 1; if (nextReadIndex \u0026gt;= m_capacity) { nextReadIndex = 0; } m_consumerData.readIndex.store(nextReadIndex, std::memory_order_release); return true; } size_t capacity() const { return m_capacity - 1; } bool isEmpty() const { return m_producerData.writeIndex.load(std::memory_order_acquire) == m_consumerData.readIndex.load(std::memory_order_acquire); } bool isFull() const { auto nextWriteIndex = m_producerData.writeIndex.load(std::memory_order_acquire) + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } return m_consumerData.readIndex.load(std::memory_order_acquire) == nextWriteIndex; } private: size_t calculateSize(size_t writeIndex, size_t readIndex) const { if (writeIndex \u0026gt;= readIndex) return writeIndex - readIndex; return m_capacity - readIndex + writeIndex; } size_t getAvailableSpace(size_t writeIndex, size_t readIndex) const { return m_capacity - 1 - calculateSize(writeIndex, readIndex); } using AtomicIndex = std::atomic\u0026lt;size_t\u0026gt;; const size_t m_capacity; T* const m_buffer; struct alignas(kCacheLineSize) { AtomicIndex readIndex = {0}; } m_consumerData; struct alignas(kCacheLineSize) { AtomicIndex writeIndex = {0}; } m_producerData; }; 优化点3: 缓存读写位置 参考：https://rigtorp.se/ringbuffer/\n缓存读写位置的优化，可以减少生产者和消费者线程的交互，提高缓存命中率。\n生产者维护自己的写位置，缓存的读位置，每次push计算可用空间，只有空间不足的情况下才会访问消费者更改的读位置，否则空间足够完全可以直接push 消费者维护自己的读位置，缓存的写位置，每次pop计算已用空间，只有空间不足的情况下才会访问生产者更改的写位置，否则空间足够完全可以直接pop 最终的基于索引缓存的成员变量\ntemplate\u0026lt;typename T\u0026gt; class SPSC3 { public: explicit SPSC3(size_t minCapacity) : m_capacity(minCapacity) , m_buffer(static_cast\u0026lt;T*\u0026gt;(std::malloc(m_capacity * sizeof(T)))) { if (!m_buffer) { throw std::bad_alloc(); } } ~SPSC3() { // We need to destruct anything that may still exist in our queue. // (No real synchronization needed at destructor time: only one // thread can be doing this.) if (!std::is_trivially_destructible\u0026lt;T\u0026gt;::value) { size_t readIndex = m_consumerData.readIndex; size_t endIndex = m_producerData.writeIndex; while (readIndex != endIndex) { m_buffer[readIndex].~T(); readIndex++; if (readIndex \u0026gt;= m_capacity) { readIndex = 0; } } } std::free(m_buffer); } SPSC3(const SPSC3\u0026amp;) = delete; SPSC3\u0026amp; operator=(const SPSC3\u0026amp;) = delete; SPSC3(SPSC3\u0026amp;\u0026amp;) = delete; SPSC3\u0026amp; operator=(SPSC3\u0026amp;\u0026amp;) = delete; template\u0026lt;class... Args\u0026gt; bool push(Args\u0026amp;\u0026amp;... args) { size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_relaxed); size_t availableSpace = getAvailableSpace(currentWriteIndex, m_producerData.readIndexCache); if (availableSpace \u0026lt; 1) { // if not enough space, refresh the cached read index and check again m_producerData.readIndexCache = m_consumerData.readIndex.load(std::memory_order_acquire); availableSpace = getAvailableSpace(currentWriteIndex, m_producerData.readIndexCache); if (availableSpace \u0026lt; 1) { return false; // not enough space } } new (\u0026amp;m_buffer[currentWriteIndex]) T(std::forward\u0026lt;Args\u0026gt;(args)...); size_t nextWriteIndex = currentWriteIndex + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } m_producerData.writeIndex.store(nextWriteIndex, std::memory_order_release); return true; } bool pop(T\u0026amp; output) { size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_relaxed); size_t availableSamples = calculateSize(m_consumerData.writeIndexCache, currentReadIndex); if (availableSamples \u0026lt; 1) { m_consumerData.writeIndexCache = m_producerData.writeIndex.load(std::memory_order_acquire); availableSamples = calculateSize(m_consumerData.writeIndexCache, currentReadIndex); if (availableSamples \u0026lt; 1) { return false; // not enough samples } } output = std::move(m_buffer[currentReadIndex]); m_buffer[currentReadIndex].~T(); size_t nextReadIndex = currentReadIndex + 1; if (nextReadIndex \u0026gt;= m_capacity) { nextReadIndex = 0; } m_consumerData.readIndex.store(nextReadIndex, std::memory_order_release); return true; } size_t capacity() const { return m_capacity - 1; } bool isEmpty() const { return m_producerData.writeIndex.load(std::memory_order_acquire) == m_consumerData.readIndex.load(std::memory_order_acquire); } bool isFull() const { auto nextWriteIndex = m_producerData.writeIndex.load(std::memory_order_acquire) + 1; if (nextWriteIndex \u0026gt;= m_capacity) { nextWriteIndex = 0; } return m_consumerData.readIndex.load(std::memory_order_acquire) == nextWriteIndex; } private: size_t calculateSize(size_t writeIndex, size_t readIndex) const { if (writeIndex \u0026gt;= readIndex) return writeIndex - readIndex; return m_capacity - readIndex + writeIndex; } size_t getAvailableSpace(size_t writeIndex, size_t readIndex) const { return m_capacity - 1 - calculateSize(writeIndex, readIndex); } using AtomicIndex = std::atomic\u0026lt;size_t\u0026gt;; const size_t m_capacity; T* const m_buffer; struct alignas(kCacheLineSize) { AtomicIndex readIndex = {0}; size_t writeIndexCache = {0}; } m_consumerData; struct alignas(kCacheLineSize) { AtomicIndex writeIndex = {0}; size_t readIndexCache = {0}; } m_producerData; }; 实测下来，相比于没有索引缓存的版本，吞吐量有明显提升。\n优化点4: 利用无符号数的回绕特性和2的幂次mask减少分支判断和取模操作 可以发现，folly版本使用了一个空槽来防止判空和判满的歧义，并且每次更新读写索引时，需要添加一个if来判断是否将索引变回0。同理，如果每次push或pop是批量操作，也需要添加if判断或者取模操作。\n我们可以利用size_t的回绕特性，以及将buffer大小设置为2的幂次来减少分支判断和取模操作：\n读写索引一直累加，直到超过size_t最大值，然后回绕到0 设置capacity为2的幂次，这样可以用位运算来代替取模操作 当前大小：writeIndex - readIndex，利用size_t的回绕特性，可以直接计算当前大小 判空：readIndex == writeIndex 判满：writeIndex - readIndex == capacity，可以发现不需要空一个槽位了！这里基于的假设是，申请的buffer的最大值是永远不可能超过size_t的最大值的，申请不到这么大的内存。 获取真实的物理索引即对应到buffer里的索引，pyhsicalIndex = index \u0026amp; (capacity - 1) push/pop，直接累加读写索引，更新的读写数据位置则使用上一条的物理索引计算方法定位 但是，实际测试下来只看到了一丢丢的提升，毕竟按照之前的写法，分支判断大部分情况下都不会进去，cpu的分支预测起作用了？或者是内存瓶颈这一点点计算优化影响不大。\n最终写出c++20版本的spsc队列：\ntemplate\u0026lt;typename T\u0026gt; class SPSC4 { public: explicit SPSC4(size_t minCapacity) : m_capacity(std::bit_ceil(minCapacity \u0026lt;= 1 ? 2 : minCapacity)) , m_mask(m_capacity - 1) , m_buffer(static_cast\u0026lt;T*\u0026gt;(std::malloc(m_capacity * sizeof(T)))) { if (!m_buffer) { throw std::bad_alloc(); } } ~SPSC4() { // We need to destruct anything that may still exist in our queue. // (No real synchronization needed at destructor time: only one // thread can be doing this.) if (!std::is_trivially_destructible\u0026lt;T\u0026gt;::value) { size_t readIndex = m_consumerData.readIndex; size_t endIndex = m_producerData.writeIndex; while (readIndex != endIndex) { m_buffer[readIndex \u0026amp; m_mask].~T(); readIndex++; } } std::free(m_buffer); } SPSC4(const SPSC4\u0026amp;) = delete; SPSC4\u0026amp; operator=(const SPSC4\u0026amp;) = delete; SPSC4(SPSC4\u0026amp;\u0026amp;) = delete; SPSC4\u0026amp; operator=(SPSC4\u0026amp;\u0026amp;) = delete; template\u0026lt;class... Args\u0026gt; bool push(Args\u0026amp;\u0026amp;... args) { size_t currentWriteIndex = m_producerData.writeIndex.load(std::memory_order_relaxed); size_t availableSpace = getAvailableSpace(currentWriteIndex, m_producerData.readIndexCache); if (availableSpace \u0026lt; 1) { // if not enough space, refresh the cached read index and check again m_producerData.readIndexCache = m_consumerData.readIndex.load(std::memory_order_acquire); availableSpace = getAvailableSpace(currentWriteIndex, m_producerData.readIndexCache); if (availableSpace \u0026lt; 1) { return false; // not enough space } } size_t physicalWriteIndex = currentWriteIndex \u0026amp; m_mask; new (\u0026amp;m_buffer[physicalWriteIndex]) T(std::forward\u0026lt;Args\u0026gt;(args)...); size_t nextWriteIndex = currentWriteIndex + 1; m_producerData.writeIndex.store(nextWriteIndex, std::memory_order_release); return true; } bool pop(T\u0026amp; output) { size_t currentReadIndex = m_consumerData.readIndex.load(std::memory_order_relaxed); size_t availableSamples = calculateSize(m_consumerData.writeIndexCache, currentReadIndex); if (availableSamples \u0026lt; 1) { m_consumerData.writeIndexCache = m_producerData.writeIndex.load(std::memory_order_acquire); availableSamples = calculateSize(m_consumerData.writeIndexCache, currentReadIndex); if (availableSamples \u0026lt; 1) { return false; // not enough samples } } size_t physicalReadIndex = currentReadIndex \u0026amp; m_mask; output = std::move(m_buffer[physicalReadIndex]); m_buffer[physicalReadIndex].~T(); size_t nextReadIndex = currentReadIndex + 1; m_consumerData.readIndex.store(nextReadIndex, std::memory_order_release); return true; } size_t capacity() const { return m_capacity; } bool isEmpty() const { return m_producerData.writeIndex.load(std::memory_order_acquire) == m_consumerData.readIndex.load(std::memory_order_acquire); } bool isFull() const { // use the warp-around logic to check if the buffer is full return (m_producerData.writeIndex.load(std::memory_order_acquire) - m_consumerData.readIndex.load(std::memory_order_acquire)) == m_capacity; } private: size_t calculateSize(size_t writeIndex, size_t readIndex) const { return writeIndex - readIndex; } size_t getAvailableSpace(size_t writeIndex, size_t readIndex) const { return m_capacity - calculateSize(writeIndex, readIndex); } using AtomicIndex = std::atomic\u0026lt;size_t\u0026gt;; const size_t m_capacity; const size_t m_mask; T* const m_buffer; struct alignas(kCacheLineSize) { AtomicIndex readIndex = {0}; size_t writeIndexCache = {0}; } m_consumerData; struct alignas(kCacheLineSize) { AtomicIndex writeIndex = {0}; size_t readIndexCache = {0}; } m_producerData; }; 写在最后 可以看到目前的开源库基本都没有提供批量操作，concurrentqueue倒是提供了bulk操作。\n那怎么才能批量操作呢？\n把上述的每次操作的索引+1改成索引+n，这样就可以批量操作了 对于push和pop，都要处理回绕问题，需要分成两块数据操作 除此之外，还可以使用Claim的方式\nClaim: 生产者问队列：“给我预留 N 个位置，把指针给我”。 Write: 生产者直接往这些指针里写数据（Zero-Copy，直接构造）。 Commit: 生产者告诉队列：“这 N 个写完了，更新索引”。 更新 发现cppcon2023 spsc的视频已经讲过了，对应的github代码。\n而且总结的条款顺序和我一样，不过作者最后放的测试结果，我的机器上没发现他写的Fifi4a比其他的开源库有明显的性能提升，毕竟这些spsc的代码都大差不差的。\n我的测试代码见miyanyan/spsc\n","date":"2025-12-08T00:00:00Z","permalink":"https://miyan.site/p/spsc%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","title":"SPSC的性能优化"},{"content":"前言 作为一名程序员，我们经常需要随时随地处理代码或者进行开发工作。虽然笔记本电脑便携性不错，但有时候我们可能只想用手机来处理一些简单的编程任务。今天我要介绍如何在Android手机上通过Termux配置一个完整的Claude Code开发环境，让你真正做到\u0026quot;手机就是开发机\u0026quot;！\n什么是Termux Termux是一个Android终端模拟器和Linux环境应用程序，它可以直接在手机上运行许多Linux命令行工具，无需root权限。通过Termux，我们可以在手机上拥有一个功能强大的命令行环境。\n安装Termux 首先需要安装Termux应用。由于Google Play上的Termux版本比较老旧，推荐从GitHub下载最新版本：\n访问 Termux GitHub Releases 下载适合你手机架构的APK文件，通常选择 termux-app_v0.118.3+github-debug_arm64-v8a.apk 在手机上安装该APK文件 配置Termux环境 安装完成后，打开Termux应用，首先更新软件包列表和已安装的软件包：\npkg update \u0026amp;\u0026amp; pkg upgrade 然后安装必要的开发工具：\npkg install nodejs pkg install git 安装Claude Code Claude Code是Anthropic官方提供的命令行工具，可以让我们直接在终端中与Claude进行交互。通过npm安装：\nnpm install -g @anthropic-ai/claude-code 配置API密钥 要使用Claude Code，需要配置API密钥。如果你有Anthropic的API密钥，可以直接使用。如果没有，可以使用第三方API服务, 这里以glm为例：\nexport ANTHROPIC_BASE_URL=https://open.bigmodel.cn/api/anthropic export ANTHROPIC_AUTH_TOKEN=YOUR_API_KEY 将 YOUR_API_KEY 替换为你的实际API密钥。\n为了方便使用，可以将这些环境变量添加到shell配置文件中：\necho \u0026#39;export ANTHROPIC_BASE_URL=https://open.bigmodel.cn/api/anthropic\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export ANTHROPIC_AUTH_TOKEN=YOUR_API_KEY\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 使用Claude Code 配置完成后，就可以直接使用Claude Code了：\nclaude 如果配置正确，你应该能看到Claude Code的启动界面。\n","date":"2025-11-05T00:00:00Z","permalink":"https://miyan.site/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%B7%A5%E5%85%B7%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E4%BD%BF%E7%94%A8termux%E5%92%8Cclaude-code/","title":"【程序员的工具】在手机上使用Termux和Claude Code"},{"content":"前言 最近手头有几个音频文件，想要提取出来，但是网上一搜信息过于繁杂，这时我突然想起来github上我star了whisper这个项目，当时只是看了一下介绍，觉得很有意思，再加上是openai出品，就star了，同时还发现一个whisper.cpp的项目，当然都没有怎么仔细看，只是知道这个项目可以提取mp3文件中的音频为文字。欸！今天就用上了~\n安装whisper 首先安装ffmpeg，并配置好环境变量\n这里我们使用uv来安装whisper，假设你已经熟悉uv的用法了\nuv tool install openai-whisper 使用whisper 打开命令行，直接输入whisper xxx.mp3即可，xxx.mp3是你要提取音频的mp3文件名，程序会自动提取出音频中的文字并打印出来。 这里我们什么都不管，直接就敲这两个字符，直接出结果（第一次会先下载模型文件），除了控制台的输出，还会生成一个xxx.txt文件，里面就是提取出的文字。 详细用法可以看官方文档 总结 不得不感叹程序员就是好呀，有这么多的开源工具可以使用，敲一点点命令就能出结果，simple is better than complex!。\n","date":"2025-10-14T00:00:00Z","permalink":"https://miyan.site/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%B7%A5%E5%85%B7%E6%80%8E%E4%B9%88%E6%8F%90%E5%8F%96mp3%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%9F%B3%E9%A2%91%E4%B8%BA%E6%96%87%E5%AD%97/","title":"【程序员的工具】怎么提取mp3文件中的音频为文字"},{"content":" 配置CMAKE_TOOLCHAIN_FILE为vcpkg\n打开vscode的设置界面，搜索cmake.configureSettings，点击Edit in settings.json并添加：\n{ \u0026#34;cmake.configureSettings\u0026#34;: { \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;: \u0026#34;${env:VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34; }, } 打开visual studio的CMakeSettings.json，设置为${env.VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake(语法和vscode不一样!!!)\n{ \u0026#34;configurations\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;x86-Debug\u0026#34;, \u0026#34;generator\u0026#34;: \u0026#34;Visual Studio 15 2017\u0026#34;, \u0026#34;configurationType\u0026#34; : \u0026#34;Debug\u0026#34;, \u0026#34;buildRoot\u0026#34;: \u0026#34;${env.LOCALAPPDATA}\\\\CMakeBuild\\\\${workspaceHash}\\\\build\\\\${name}\u0026#34;, \u0026#34;cmakeCommandArgs\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;buildCommandArgs\u0026#34;: \u0026#34;-m -v:minimal\u0026#34;, \u0026#34;variables\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;D:\\\\src\\\\vcpkg\\\\scripts\\\\buildsystems\\\\vcpkg.cmake\u0026#34; }] }] } 参考：https://github.com/MicrosoftDocs/vcpkg-docs/blob/main/vcpkg/examples/installing-and-using-packages.md#cmake\n配置generator为Ninja 打开vscode的设置界面，搜索cmake.generator，填入Ninja即可。\n","date":"2025-07-11T00:00:00Z","permalink":"https://miyan.site/p/vscode-cmake-%E8%AE%BE%E7%BD%AE/","title":"vscode cmake 设置"},{"content":"参考Python settings reference\npython pyi 文件的搜索目录 pyi文件用于提示IDE自动补全和高亮，在vscode中对应stubPath这个参数，它的默认值是./typings，也就是根目录的typings文件夹，所以把所有的pyi文件放到该目录就可以使vscode里的python代码自动提示并高亮了 ","date":"2025-05-30T00:00:00Z","permalink":"https://miyan.site/p/vscode-python-%E8%AE%BE%E7%BD%AE/","title":"vscode python 设置"},{"content":"发现yalantinglibs的type_string的输出漏掉了const关键字，问了作者发现确实是一个bug，在提pr的过程也发现了这种实现还是有缺陷的，在此记录下\n原理 获取到各个编译器下的原有名字\n使用编译器宏获取，msvc下为__FUNCSIG__，gcc和clang下为__PRETTY_FUNCTION__ 使用c++20的source_location的function_name获取，但是注意，这个函数不是所有的版本的适用，见Improve std::source_location::function_name() informativeness #3063 最终采用宏的方式获取\n进行拆分截断\n创建一个模板函数，模板参数typename T，在函数内使用上述的宏得到原始的字符串 三大编译器的输出都是 前缀 + 内容 + 后缀 的方式，且前后缀的长度固定，因此找到前缀和后缀的位置并拆分 可以先建立一个模板，我们以int为模板，编译期内得到前后缀长度 msvc: class std::basic_string_view\u0026lt;char,struct std::char_traits\u0026lt;char\u0026gt; \u0026gt; __cdecl get_raw_name\u0026lt;int\u0026gt;(void) gcc: constexpr std::string_view get_raw_name() [with T = int; std::string_view = std::basic_string_view\u0026lt;char\u0026gt;] clang: std::string_view get_raw_name() [T = int] 【缺陷】并不能保证各个编译器下的字符串完全一致，包括但不限于多或少一个空格，逗号的位置等等（msvc还会加上class struct union关键字！）\n代码 msvc、gcc、clang下均可运行\n#include \u0026lt;string_view\u0026gt; template \u0026lt;typename T\u0026gt; constexpr std::string_view get_raw_name() { #ifdef _MSC_VER return __FUNCSIG__; #else return __PRETTY_FUNCTION__; #endif } template \u0026lt;typename T\u0026gt; inline constexpr std::string_view type_string() { constexpr std::string_view sample = get_raw_name\u0026lt;int\u0026gt;(); constexpr size_t prefix_length = sample.find(\u0026#34;int\u0026#34;); constexpr size_t suffix_length = sample.size() - prefix_length - 3; constexpr std::string_view str = get_raw_name\u0026lt;T\u0026gt;(); return str.substr(prefix_length, str.size() - prefix_length - suffix_length); } 代码确实很简洁！但是输出不能保证各个编译器的一致性，具体输出见： compiler explorer 在线运行链接\n","date":"2025-03-31T00:00:00Z","permalink":"https://miyan.site/p/c-%E7%BC%96%E8%AF%91%E6%9C%9F%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D/","title":"C++ 编译期获取类名"},{"content":" 切换头文件/源文件(F4) vscode: c++插件搜索switchheadersource(注意不加空格，这样自带的c++和clangd都能搜索出来) visual studio: 搜索切换标题代码文件 ","date":"2025-03-25T00:00:00Z","permalink":"https://miyan.site/p/vscode/visual-studio-%E5%BF%AB%E6%8D%B7%E5%BB%BA%E8%AE%BE%E7%BD%AE/","title":"vscode/visual studio 快捷建设置"},{"content":" 禁用microsoft c++插件的提示 打开vscode的设置界面，搜索c++ engine，选择C_Cpp.intelliSenseEngine，设置为disabled\n对应的settings.json设置为\n{ \u0026#34;C_Cpp.intelliSenseEngine\u0026#34;: \u0026#34;disabled\u0026#34; } 添加clangd参数\n不自动添加头文件 补全时不自动填写函数参数 打开vscode的设置界面，搜索clangd arguments，选择clangd.arguments，点击Add Item添加对应参数。\n对应的settings.json设置为\n{ \u0026#34;clangd.arguments\u0026#34;: [ \u0026#34;--header-insertion=never\u0026#34;, \u0026#34;--function-arg-placeholders=0\u0026#34; ], } ","date":"2025-03-14T00:00:00Z","permalink":"https://miyan.site/p/vscode-clangd-%E8%AE%BE%E7%BD%AE/","title":"vscode clangd 设置"},{"content":" cmake 输出相关信息\nmessage(STATUS \u0026#34;CMake version: ${CMAKE_VERSION}\u0026#34;) message(STATUS \u0026#34;CMake C compiler: ${CMAKE_C_COMPILER}\u0026#34;) message(STATUS \u0026#34;CMake CXX compiler: ${CMAKE_CXX_COMPILER}\u0026#34;) message(STATUS \u0026#34;Build directory: ${PROJECT_BINARY_DIR}\u0026#34;) message(STATUS \u0026#34;Build type: ${CMAKE_BUILD_TYPE}\u0026#34;) 判断是否被当作subproject\n# Determine if is built as a subproject (using add_subdirectory) # or if it is the master project. if (NOT DEFINED XXX_MASTER_PROJECT) set(XXX_MASTER_PROJECT OFF) if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR) set(XXX_MASTER_PROJECT ON) endif () message(STATUS \u0026#34;Is build as a master project: ${XXX_MASTER_PROJECT}\u0026#34;) endif () 生成compile_commands.json以供clangd使用\nwindows下需要使用Ninja，如果使用vscode则在设置里把cmake.generator设置为Ninja\n# generate compile_commands.json set(CMAKE_EXPORT_COMPILE_COMMANDS ON) cmake设置rpath，unix下搜索同目录下的so文件\nset(CMAKE_SKIP_BUILD_RPATH FALSE) # 加入rpath set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE) # 表示编译的时候是否使用CMAKE_INSTALL_RPATH作为rpath路径 set(CMAKE_INSTALL_RPATH \u0026#34;\\${ORIGIN}\u0026#34;) # 设置rpath安装时的路径，${ORIGIN}代表运行时当前目录 参考How to set rpath origin in cmake?\ncmake设置输出目录，解决windows下命令行生成目录不正确但是IDE生成目录正确的问题 一定要放在project命令后面\nset(XXX_OUTPUT_DIR ${PROJECT_BINARY_DIR}/bin) set(XXX_OUTPUT_LIB_DIR ${PROJECT_BINARY_DIR}/lib) set(XXX_OUTPUT_PDB_DIR ${PROJECT_BINARY_DIR}/pdb) set(XXX_PLUGINS_OUTPUT_DIR ${XXX_OUTPUT_DIR}/plugins) # do not set cmake internal variables in functions(not work...) # difference between windows and linux, see https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#runtime-output-artifacts set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${XXX_OUTPUT_DIR}) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${XXX_OUTPUT_DIR}) set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${XXX_OUTPUT_LIB_DIR}) set(CMAKE_PDB_OUTPUT_DIRECTORY ${XXX_OUTPUT_PDB_DIR}) foreach(config IN ITEMS Debug Release RelWithDebInfo MinSizeRel) string(TOUPPER \u0026#34;${config}\u0026#34; CONFIG_UPPER) set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${CONFIG_UPPER} \u0026#34;${XXX_OUTPUT_DIR}\u0026#34;) set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CONFIG_UPPER} \u0026#34;${XXX_OUTPUT_DIR}\u0026#34;) set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${CONFIG_UPPER} \u0026#34;${XXX_OUTPUT_LIB_DIR}\u0026#34;) set(CMAKE_PDB_OUTPUT_DIRECTORY_${CONFIG_UPPER} \u0026#34;${XXX_OUTPUT_PDB_DIR}\u0026#34;) endforeach() cmake开启fPIC\nif (NOT DEFINED CMAKE_POSITION_INDEPENDENT_CODE) # Otherwise we can\u0026#39;t link .so libs with .a libs set(CMAKE_POSITION_INDEPENDENT_CODE ON) endif() cmake统一符号可见性，默认隐藏\nif (XXX_MASTER_PROJECT AND NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET) set(CMAKE_CXX_VISIBILITY_PRESET hidden CACHE STRING \u0026#34;Preset for the export of private symbols\u0026#34;) set_property(CACHE CMAKE_CXX_VISIBILITY_PRESET PROPERTY STRINGS hidden default) endif () if (XXX_MASTER_PROJECT AND NOT DEFINED CMAKE_VISIBILITY_INLINES_HIDDEN) set(CMAKE_VISIBILITY_INLINES_HIDDEN ON CACHE BOOL \u0026#34;Whether to add a compile flag to hide symbols of inline functions\u0026#34;) endif () 集成vcpkg toolchain\nif(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE) message(STATUS \u0026#34;VCPKG_ROOT: $ENV{VCPKG_ROOT}\u0026#34;) set(CMAKE_TOOLCHAIN_FILE \u0026#34;$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34; CACHE STRING \u0026#34;\u0026#34;) endif() 集成vcpkg manifest 一定要放在project命令之前\nif (XXX_RUN_TEST) list(APPEND VCPKG_MANIFEST_FEATURES \u0026#34;tests\u0026#34;) endif() if (XXX_BUILD_EXAMPLES) list(APPEND VCPKG_MANIFEST_FEATURES \u0026#34;examples\u0026#34;) endif() if (XXX_BUILD_BENCHMARKS) list(APPEND VCPKG_MANIFEST_FEATURES \u0026#34;benchmarks\u0026#34;) endif() ctest集成gtest\nenable_testing() file(GLOB_RECURSE source CONFIGURE_DEPENDS *.h *.cpp) find_package(GTest CONFIG REQUIRED) add_executable(test_main ${source}) target_link_libraries(test_main PRIVATE GTest::gtest) include(GoogleTest) gtest_discover_tests(test_main WORKING_DIRECTORY ${XXX_OUTPUT_DIR}) cmake 拷贝文件（如dll、exe等）到指定目录\nset(DLL_PATH ******) set(OUTPUT_DIR ******) add_custom_command(TARGET XXX POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different ${DLL_PATH} ${OUTPUT_DIR} COMMENT \u0026#34;Copying DLL to output directory\u0026#34; ) cmake 拷贝vcpkg安装库的license到指定目录\n使用方法: copy_licenses_from_vcpkg(TARGET_NAME your_target OUTPUT_DIR license)\nfunction(copy_licenses_from_vcpkg) set(options) set(oneValueArgs OUTPUT_DIR TARGET_NAME) set(multiValueArgs) cmake_parse_arguments(ARG \u0026#34;${options}\u0026#34; \u0026#34;${oneValueArgs}\u0026#34; \u0026#34;${multiValueArgs}\u0026#34; ${ARGN}) # 参数校验 if(NOT ARG_TARGET_NAME) message(FATAL_ERROR \u0026#34;No TARGET_NAME specified\u0026#34;) endif() if(NOT TARGET ${ARG_TARGET_NAME}) message(FATAL_ERROR \u0026#34;No ${ARG_TARGET_NAME} target found\u0026#34;) endif() # 设置默认输出目录 if(NOT ARG_OUTPUT_DIR) set(ARG_OUTPUT_DIR \u0026#34;${CMAKE_CURRENT_BINARY_DIR}/vcpkg_licenses\u0026#34;) endif() # 创建许可证复制目标 add_custom_target(_vcpkg_license_copy ALL COMMAND ${CMAKE_COMMAND} -E make_directory \u0026#34;${ARG_OUTPUT_DIR}\u0026#34; COMMENT \u0026#34;[vcpkg] Preparing license directory: ${ARG_OUTPUT_DIR}\u0026#34; ) # 遍历所有许可证文件 file(GLOB license_dirs \u0026#34;${VCPKG_INSTALLED_DIR}/${VCPKG_TARGET_TRIPLET}/share/*\u0026#34;) foreach(license_dir IN LISTS license_dirs) if(EXISTS \u0026#34;${license_dir}/copyright\u0026#34;) get_filename_component(lib_name \u0026#34;${license_dir}\u0026#34; NAME) # 排除隐藏目录 if(NOT lib_name MATCHES \u0026#34;^\\\\.\u0026#34;) add_custom_command(TARGET _vcpkg_license_copy POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different \u0026#34;${license_dir}/copyright\u0026#34; \u0026#34;${ARG_OUTPUT_DIR}/${lib_name}.LICENSE\u0026#34; COMMENT \u0026#34;Copying ${lib_name} license\u0026#34; VERBATIM ) endif() endif() endforeach() # 自动绑定依赖关系 add_dependencies(${ARG_TARGET_NAME} _vcpkg_license_copy) endfunction() 开启ccache\n# Configure CCache if available find_program(CCACHE_PROGRAM ccache) if(CCACHE_PROGRAM) message(STATUS \u0026#34;Set up ccache ...\u0026#34;) set(CMAKE_C_COMPILER_LAUNCHER \u0026#34;${CCACHE_PROGRAM}\u0026#34;) set(CMAKE_CXX_COMPILER_LAUNCHER \u0026#34;${CCACHE_PROGRAM}\u0026#34;) endif() ","date":"2025-03-04T00:00:00Z","permalink":"https://miyan.site/p/cmake%E7%BC%96%E5%86%99%E6%A8%A1%E6%9D%BF/","title":"cmake编写模板"},{"content":"起因 看到这个博客里写道这样写进行了初始化操作\nauto buffer_size = 5*1024*1024; auto buffer = std::make_unique\u0026lt;char[]\u0026gt;(buffer_size); 评论区jajuju提出可以使用创建buffer\n其实这里的情况是 make_unique 里用的 new 表达式是 new T[n]() ，对于 char 数组会进行零初始化。 如果换用 make_unique_for_overwrite，里面的 new 表达式就是 new T[n]，此时进行默认初始化，就不会给 char 数组内容清零。\n瞬间感觉学到了一个新知识，这个make_unique_for_overwrite真是第一次见了(没看过cppreference上的make_unique一节\u0026hellip;)\n源码分析 我们以cppreference上的实现分析下源码：\n非数组类型\ntemplate\u0026lt;class T\u0026gt; requires (!std::is_array_v\u0026lt;T\u0026gt;) std::unique_ptr\u0026lt;T\u0026gt; make_unique_for_overwrite() { return std::unique_ptr\u0026lt;T\u0026gt;(new T); } 效果类似于 new T，但没有 ()，因此不会执行默认初始化（特别是对于 POD 类型）。 构造函数仍然会被调用（如果 T 不是 POD）。 动态数组\ntemplate\u0026lt;class T\u0026gt; requires std::is_unbounded_array_v\u0026lt;T\u0026gt; std::unique_ptr\u0026lt;T\u0026gt; make_unique_for_overwrite(std::size_t n) { return std::unique_ptr\u0026lt;T\u0026gt;(new std::remove_extent_t\u0026lt;T\u0026gt;[n]); } 分配 n 个 T 元素的未初始化数组，不调用 ()，因此不会默认初始化（类似 new T[n]）。 不会调用构造函数（如果 T 是 POD）。 禁止定长数组\ntemplate\u0026lt;class T, class... Args\u0026gt; requires std::is_bounded_array_v\u0026lt;T\u0026gt; void make_unique_for_overwrite(Args\u0026amp;\u0026amp;...) = delete; 因为定长数组不能通过 new 进行动态分配，所以编译时禁止。 参考 MSVC STL实现\n","date":"2025-02-24T00:00:00Z","permalink":"https://miyan.site/p/%E4%BD%BF%E7%94%A8stdmake_unique_for_overwrite%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAchar%E6%95%B0%E7%BB%84%E5%BD%93%E7%BC%93%E5%86%B2%E5%8C%BA/","title":"使用std::make_unique_for_overwrite创建一个char数组当缓冲区"},{"content":"msvc 源码见https://github.com/microsoft/STL/blob/main/stl/inc/functional\n预备知识 参数类型，可以分为一元(unary)和二元(binary)，这个概念很重要，gcc的实现里也用到 可以看到msvc里定义了三个_Arg_types：无参数类型；接受一个参数，一元；接受两个参数，二元。 并且_Arg_types没有成员变量，只是定义了对应的类型。\ntemplate \u0026lt;class... _Types\u0026gt; struct _Arg_types {}; // provide argument_type, etc. when sizeof...(_Types) is 1 or 2 template \u0026lt;class _Ty1\u0026gt; struct _Arg_types\u0026lt;_Ty1\u0026gt; { _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 _ARGUMENT_TYPE_NAME; }; template \u0026lt;class _Ty1, class _Ty2\u0026gt; struct _Arg_types\u0026lt;_Ty1, _Ty2\u0026gt; { _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 _FIRST_ARGUMENT_TYPE_NAME; _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty2 _SECOND_ARGUMENT_TYPE_NAME; }; 一个function应该有什么接口 能调用。必须的！ 能复制。 能移动。 能删除。 我们看一下msvc实现的接口类，正好符合这四个特点。 这里需要注意关键字__declspec(novtable)，它用于告诉编译器不要生成vtable，这样就可以减少额外的开销，毕竟function作为一个很基础的功能，当然是能省则省。\ntemplate \u0026lt;class _Rx, class... _Types\u0026gt; class __declspec(novtable) _Func_base { // abstract base for implementation types public: virtual _Func_base* _Copy(void*) const = 0; virtual _Func_base* _Move(void*) noexcept = 0; virtual _Rx _Do_call(_Types\u0026amp;\u0026amp;...) = 0; virtual const type_info\u0026amp; _Target_type() const noexcept = 0; virtual void _Delete_this(bool) noexcept = 0; #if _HAS_STATIC_RTTI const void* _Target(const type_info\u0026amp; _Info) const noexcept { return _Target_type() == _Info ? _Get() : nullptr; } #endif // _HAS_STATIC_RTTI _Func_base() = default; _Func_base(const _Func_base\u0026amp;) = delete; _Func_base\u0026amp; operator=(const _Func_base\u0026amp;) = delete; // dtor non-virtual due to _Delete_this() private: virtual const void* _Get() const noexcept = 0; }; 走进源码 内存对象 首先进入function class，它继承自_Get_function_impl::type，public函数里都是构造函数相关，我们着重观察这个_Get_function_impl实现。没有成员变量\ntemplate \u0026lt;class _Fty\u0026gt; class function : public _Get_function_impl\u0026lt;_Fty\u0026gt;::type { // wrapper for callable objects private: using _Mybase = typename _Get_function_impl\u0026lt;_Fty\u0026gt;::type; public: // 构造函数 }; 可以看到_Get_function_impl的主要部分为_Get_function_impl::type，它是_Func_class\u0026lt;_Ret,_Types\u0026hellip;\u0026gt;。没有成员变量\ntemplate \u0026lt;class _Tx\u0026gt; struct _Get_function_impl { static_assert(_Always_false\u0026lt;_Tx\u0026gt;, \u0026#34;std::function only accepts function types as template arguments.\u0026#34;); }; #define _GET_FUNCTION_IMPL(CALL_OPT, X1, X2, X3) \\ template \u0026lt;class _Ret, class... _Types\u0026gt; \\ struct _Get_function_impl\u0026lt;_Ret CALL_OPT(_Types...)\u0026gt; { /* determine type from argument list */ \\ using type = _Func_class\u0026lt;_Ret, _Types...\u0026gt;; \\ }; _NON_MEMBER_CALL(_GET_FUNCTION_IMPL, X1, X2, X3) #undef _GET_FUNCTION_IMPL _Func_class 模板参数为 返回值 + 可变参，继承自_Arg_types\u0026lt;_Types\u0026hellip;\u0026gt;，根据参数个数拿到了对应的类型。\nprivate里有一个成员变量_Storage_Mystorage，它是一个联合体，在64位平台上，_Small_object_num_ptrs = 6 + 16 / sizeof(void*) = 8，_Space_size = (_Small_object_num_ptrs - 1) * sizeof(void*) = 56， 所以这个_Mystorage的实际大小为64个byte。\nunion _Storage { // storage for small objects (basic_string is small) max_align_t _Dummy1; // for maximum alignment char _Dummy2[_Space_size]; // to permit aliasing _Ptrt* _Ptrs[_Small_object_num_ptrs]; // _Ptrs[_Small_object_num_ptrs - 1] is reserved }; public里为构造函数 + 析构函数 + 重载operator()，符合我们的常规认知，function就是一个根据传参执行的函数。 这里我们主要看三个函数，_Set、_Getimpl、_Tidy，它们都是在对_Mystorage的最后一个_Ptr进行操作\n_Set，赋值给_Mystorage的最后一个_Ptr\nvoid _Set(_Ptrt* _Ptr) noexcept { // store pointer to object _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr; } _Getimpl，返回_Mystorage的最后一个_Ptr\n_Ptrt* _Getimpl() const noexcept { // get pointer to object return _Mystorage._Ptrs[_Small_object_num_ptrs - 1]; } _Tidy，首先删除对应指针，然后_Mystorage的最后一个_Ptr置空。\nvoid _Tidy() noexcept { if (!_Empty()) { // destroy callable object and maybe delete it _Getimpl()-\u0026gt;_Delete_this(!_Local()); _Set(nullptr); } } protected里主要为内存分配相关函数，我们重点关注内存分配函数_Reset，可以看到根据_Is_large主要分为两种分配方式，\n// 当函数对象的大小超过56字节，或者对齐字节数大于max_align_t，或者是否可以不抛异常移动构造 template \u0026lt;class _Impl\u0026gt; // determine whether _Impl must be dynamically allocated _INLINE_VAR constexpr bool _Is_large = sizeof(_Impl) \u0026gt; _Space_size || alignof(_Impl) \u0026gt; alignof(max_align_t) || !_Impl::_Nothrow_move::value; 小内存函数对象，调用 placement new，直接构造在_Mystorage上\n大内存函数对象，需要动态分配，内存分配到堆上\ntemplate \u0026lt;class _Fx\u0026gt; void _Reset(_Fx\u0026amp;\u0026amp; _Val) { // store copy of _Val if (!_Test_callable(_Val)) { // null member pointer/function pointer/std::function return; // already empty } using _Impl = _Func_impl_no_alloc\u0026lt;decay_t\u0026lt;_Fx\u0026gt;, _Ret, _Types...\u0026gt;; if constexpr (_Is_large\u0026lt;_Impl\u0026gt;) { // dynamically allocate _Val _Set(_Global_new\u0026lt;_Impl\u0026gt;(_STD forward\u0026lt;_Fx\u0026gt;(_Val))); } else { // store _Val in-situ _Set(::new (static_cast\u0026lt;void*\u0026gt;(\u0026amp;_Mystorage)) _Impl(_STD forward\u0026lt;_Fx\u0026gt;(_Val))); } } MSVC主要源码 template \u0026lt;class _Ret, class... _Types\u0026gt; class _Func_class : public _Arg_types\u0026lt;_Types...\u0026gt; { public: using result_type = _Ret; using _Ptrt = _Func_base\u0026lt;_Ret, _Types...\u0026gt;; _Func_class() noexcept { _Set(nullptr); } _Ret operator()(_Types... _Args) const { if (_Empty()) { _Xbad_function_call(); } const auto _Impl = _Getimpl(); return _Impl-\u0026gt;_Do_call(_STD forward\u0026lt;_Types\u0026gt;(_Args)...); } ~_Func_class() noexcept { _Tidy(); } protected: template \u0026lt;class _Fx, class _Function\u0026gt; using _Enable_if_callable_t = enable_if_t\u0026lt;conjunction_v\u0026lt;negation\u0026lt;is_same\u0026lt;_Remove_cvref_t\u0026lt;_Fx\u0026gt;, _Function\u0026gt;\u0026gt;, _Is_invocable_r\u0026lt;_Ret, decay_t\u0026lt;_Fx\u0026gt;\u0026amp;, _Types...\u0026gt;\u0026gt;, int\u0026gt;; bool _Empty() const noexcept { return !_Getimpl(); } void _Reset_copy(const _Func_class\u0026amp; _Right) { // copy _Right\u0026#39;s stored object if (!_Right._Empty()) { _Set(_Right._Getimpl()-\u0026gt;_Copy(\u0026amp;_Mystorage)); } } void _Reset_move(_Func_class\u0026amp;\u0026amp; _Right) noexcept { // move _Right\u0026#39;s stored object if (!_Right._Empty()) { if (_Right._Local()) { // move and tidy _Set(_Right._Getimpl()-\u0026gt;_Move(\u0026amp;_Mystorage)); _Right._Tidy(); } else { // steal from _Right _Set(_Right._Getimpl()); _Right._Set(nullptr); } } } template \u0026lt;class _Fx\u0026gt; void _Reset(_Fx\u0026amp;\u0026amp; _Val) { // store copy of _Val if (!_Test_callable(_Val)) { // null member pointer/function pointer/std::function return; // already empty } using _Impl = _Func_impl_no_alloc\u0026lt;decay_t\u0026lt;_Fx\u0026gt;, _Ret, _Types...\u0026gt;; if constexpr (_Is_large\u0026lt;_Impl\u0026gt;) { // dynamically allocate _Val _Set(_Global_new\u0026lt;_Impl\u0026gt;(_STD forward\u0026lt;_Fx\u0026gt;(_Val))); } else { // store _Val in-situ _Set(::new (static_cast\u0026lt;void*\u0026gt;(\u0026amp;_Mystorage)) _Impl(_STD forward\u0026lt;_Fx\u0026gt;(_Val))); } } void _Tidy() noexcept { if (!_Empty()) { // destroy callable object and maybe delete it _Getimpl()-\u0026gt;_Delete_this(!_Local()); _Set(nullptr); } } void _Swap(_Func_class\u0026amp; _Right) noexcept { // swap contents with contents of _Right if (!_Local() \u0026amp;\u0026amp; !_Right._Local()) { // just swap pointers _Ptrt* _Temp = _Getimpl(); _Set(_Right._Getimpl()); _Right._Set(_Temp); } else { // do three-way move _Func_class _Temp; _Temp._Reset_move(_STD move(*this)); _Reset_move(_STD move(_Right)); _Right._Reset_move(_STD move(_Temp)); } } private: bool _Local() const noexcept { // test for locally stored copy of object return _Getimpl() == static_cast\u0026lt;const void*\u0026gt;(\u0026amp;_Mystorage); } union _Storage { // storage for small objects (basic_string is small) max_align_t _Dummy1; // for maximum alignment char _Dummy2[_Space_size]; // to permit aliasing _Ptrt* _Ptrs[_Small_object_num_ptrs]; // _Ptrs[_Small_object_num_ptrs - 1] is reserved }; _Storage _Mystorage; enum { _EEN_IMPL = _Small_object_num_ptrs - 1 }; // helper for expression evaluator _Ptrt* _Getimpl() const noexcept { // get pointer to object return _Mystorage._Ptrs[_Small_object_num_ptrs - 1]; } void _Set(_Ptrt* _Ptr) noexcept { // store pointer to object _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr; } }; 如何调用 通过上一节我们可以了解到std::function核心的内存就是_Storage_Mystorage，可以通过_Mystorage的最后一个_Ptr得到函数调用的指针，那有了函数指针，怎么调用呢？ 在_Func_class::_Reset中我们首先分配了对象_Func_impl_no_alloc，然后把其指针赋值给_Mystorage的最后一个_Ptr，这个_Func_impl_no_alloc就是函数调用的具体实现， 它继承自_Func_base，主要实现了调用、移动、复制、删除接口：\ntemplate \u0026lt;class _Callable, class _Rx, class... _Types\u0026gt; class _Func_impl_no_alloc final : public _Func_base\u0026lt;_Rx, _Types...\u0026gt; { // derived class for specific implementation types that don\u0026#39;t use allocators public: using _Mybase = _Func_base\u0026lt;_Rx, _Types...\u0026gt;; using _Nothrow_move = is_nothrow_move_constructible\u0026lt;_Callable\u0026gt;; template \u0026lt;class _Other, enable_if_t\u0026lt;!is_same_v\u0026lt;_Func_impl_no_alloc, decay_t\u0026lt;_Other\u0026gt;\u0026gt;, int\u0026gt; = 0\u0026gt; explicit _Func_impl_no_alloc(_Other\u0026amp;\u0026amp; _Val) : _Callee(_STD forward\u0026lt;_Other\u0026gt;(_Val)) {} // dtor non-virtual due to _Delete_this() private: _Mybase* _Copy(void* _Where) const override { if constexpr (_Is_large\u0026lt;_Func_impl_no_alloc\u0026gt;) { return _Global_new\u0026lt;_Func_impl_no_alloc\u0026gt;(_Callee); } else { return ::new (_Where) _Func_impl_no_alloc(_Callee); } } _Mybase* _Move(void* _Where) noexcept override { if constexpr (_Is_large\u0026lt;_Func_impl_no_alloc\u0026gt;) { return nullptr; } else { return ::new (_Where) _Func_impl_no_alloc(_STD move(_Callee)); } } _Rx _Do_call(_Types\u0026amp;\u0026amp;... _Args) override { // call wrapped function return _Invoker_ret\u0026lt;_Rx\u0026gt;::_Call(_Callee, _STD forward\u0026lt;_Types\u0026gt;(_Args)...); } const void* _Get() const noexcept override { return _STD addressof(_Callee); } void _Delete_this(bool _Dealloc) noexcept override { // destroy self this-\u0026gt;~_Func_impl_no_alloc(); if (_Dealloc) { _Deallocate\u0026lt;alignof(_Func_impl_no_alloc)\u0026gt;(this, sizeof(_Func_impl_no_alloc)); } } _Callable _Callee; }; 我们主要看一下_Do_call函数，它内部调用了_Invoker_ret\u0026lt;_Rx\u0026gt;::_Call，最终调用std::invoke完成函数调用\n// helper to give INVOKE an explicit return type; avoids undesirable Expression SFINAE template \u0026lt;class _Rx, bool = is_void_v\u0026lt;_Rx\u0026gt;\u0026gt; struct _Invoker_ret { // selected for _Rx being cv void template \u0026lt;class _Fx, class... _Valtys\u0026gt; static _CONSTEXPR20 void _Call(_Fx\u0026amp;\u0026amp; _Func, _Valtys\u0026amp;\u0026amp;... _Vals) noexcept(_Select_invoke_traits\u0026lt;_Fx, _Valtys...\u0026gt;::_Is_nothrow_invocable::value) { // INVOKE, \u0026#34;implicitly\u0026#34; converted to void _STD invoke(static_cast\u0026lt;_Fx\u0026amp;\u0026amp;\u0026gt;(_Func), static_cast\u0026lt;_Valtys\u0026amp;\u0026amp;\u0026gt;(_Vals)...); } }; template \u0026lt;class _Rx\u0026gt; struct _Invoker_ret\u0026lt;_Rx, false\u0026gt; { // selected for all _Rx other than cv void and _Unforced template \u0026lt;class _Fx, class... _Valtys\u0026gt; static _CONSTEXPR20 _Rx _Call(_Fx\u0026amp;\u0026amp; _Func, _Valtys\u0026amp;\u0026amp;... _Vals) noexcept(_Select_invoke_traits\u0026lt;_Fx, _Valtys...\u0026gt;::template _Is_nothrow_invocable_r\u0026lt;_Rx\u0026gt;::value) { // INVOKE, implicitly converted to _Rx return _STD invoke(static_cast\u0026lt;_Fx\u0026amp;\u0026amp;\u0026gt;(_Func), static_cast\u0026lt;_Valtys\u0026amp;\u0026amp;\u0026gt;(_Vals)...); } }; template \u0026lt;\u0026gt; struct _Invoker_ret\u0026lt;_Unforced, false\u0026gt; { // selected for _Rx being _Unforced template \u0026lt;class _Fx, class... _Valtys\u0026gt; static _CONSTEXPR20 auto _Call(_Fx\u0026amp;\u0026amp; _Func, _Valtys\u0026amp;\u0026amp;... _Vals) noexcept( _Select_invoke_traits\u0026lt;_Fx, _Valtys...\u0026gt;::_Is_nothrow_invocable::value) -\u0026gt; decltype(_STD invoke(static_cast\u0026lt;_Fx\u0026amp;\u0026amp;\u0026gt;(_Func), static_cast\u0026lt;_Valtys\u0026amp;\u0026amp;\u0026gt;(_Vals)...)) { // INVOKE, unchanged return _STD invoke(static_cast\u0026lt;_Fx\u0026amp;\u0026amp;\u0026gt;(_Func), static_cast\u0026lt;_Valtys\u0026amp;\u0026amp;\u0026gt;(_Vals)...); } }; gcc ","date":"2024-12-22T00:00:00Z","permalink":"https://miyan.site/p/c-stdfunction-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","title":"C++ std::function 实现原理"},{"content":"在windows下使用cythonize可以将py文件编译成pyd，这样就完成了初步的python代码加密工作 使用前需要先安装Cython pip install Cython 然后对py文件执行命令cythonize -i -3 --directive always_allow_keywords=true xxx.py 这里有一个要注意的点：\n\u0026ndash;directive always_allow_keywords=true. 这一个参数是强制生成keyword，因为有的人在写python文件时，会写成:\ndef func(input): // do somthing return True res = func(input=input) # 注意这里，input=input，相当于需要一个keyword 但是cython默认不会为一个参数的函数生成keyword，因此当出现上面这种情况时，就会出现py可以运行pyd不可以运行的情况。见always_allow_keywords，文档里说关闭always_allow_keywords会slightly faster，但是都用python了这点性能总感觉大差不差的，毕竟只是针对只有一个入参的函数才有用。\n下面是一个脚本，用于把目录下的所有py文件转换为pyd\nimport os import sys import subprocess from pathlib import Path def compile_to_pyd(src_path: str, auto_delete: bool): if (os.path.isfile(src_path)): print(\u0026#34;input file\u0026#34;) py_files = [] if (src_path.endswith(\u0026#34;.py\u0026#34;)): py_files.append(src_path) else: print(\u0026#34;input dir\u0026#34;) # 获取目录中的所有.py文件 py_files_Path = list(Path(src_path).rglob(\u0026#39;*.py\u0026#39;)) py_files = [str(file.absolute()) for file in py_files_Path] if len(py_files) == 0: print(\u0026#34;no py files...\u0026#34;) return print(f\u0026#34;building {len(py_files)} py files...\u0026#34;) # 使用Cython编译为.pyd文件 files_str = \u0026#34; \u0026#34;.join(py_files) # --directive always_allow_keywords=true 是为了防止有人写 res = fun(a = a) 这种情况 # cython默认对于单参数不生成keyword，因此要强制开启 # https://cython.readthedocs.io/en/latest/src/userguide/source_files_and_compilation.html compile_command = f\u0026#34;cythonize -i -3 --directive always_allow_keywords=true {files_str}\u0026#34; print(compile_command) subprocess.run(compile_command, shell=True, check=True) if auto_delete: # 删除生成的 .py 和 .c 文件 for py_file in py_files: c_file = py_file[:-2] + \u0026#34;c\u0026#34; if os.path.exists(c_file): os.remove(c_file) if os.path.exists(py_file): os.remove(py_file) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) \u0026lt; 2: print(\u0026#34;Usage: python compile_to_pyd.py \u0026lt;directory\u0026gt;\u0026#34;) sys.exit(1) dir_name = sys.argv[1] auto_delete = \u0026#34;--auto-delete\u0026#34; in sys.argv compile_to_pyd(dir_name, auto_delete) ","date":"2024-11-10T00:00:00Z","permalink":"https://miyan.site/p/cython%E5%B0%86py%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E6%88%90pyd/so%E6%96%87%E4%BB%B6/","title":"cython，将py文件编译成pyd/so文件"},{"content":"DP 数位DP 是什么 数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制\n为什么 为什么要一位位的判断？因为对一个区间内的数的统计，往往有相似的地方。比如 [1000, 1999] 和 [2000, 2999] 只是第一位发生了变化，后三位变化类似，那么只需要后三位的变化能通用化，那么不就可以进行DP了。\n数位DP一般有这些特征：\n计数。 判断的条件可以转化为用每一位去考虑。 有数字的区间。常见的有 小于x的 大于x的小于y的 等等 这个区间很大。否则可以直接暴力了。 怎么做 首先因为区间很大，所以一般给定的是一个字符串形式的数字，我们假定为s，这个数字的总位数是n\n参考\ndp[i][j]表示当前在第i位，前面维护了一个为j的值，且后面的位数可以随便选时的数字个数\n定义函数f(i, mask, isLimit, isNum)表示构造从左往右第i位及其之后数位合法的方案数，其余参数的含义为：\nmask表示前面选过的数字集合，换句话说，第i位数字不能在mask中 isLimit表示当前是否受到了约束，若为真，则第i位填入的数字至多为s[i]，否则可以是9。如果在受到约束的情况下填入9，则后面还会被约束 isNum表示前i位是否填了数字，若为真，则填入的数字可以是从0开始，否则不能有前导0，即可以跳过当前数字或者从1开始 注意mask是可以变通的，比如\n2719. 统计整数数目, mask 是当前的数字和 则递归入口为:f(0, 0, true, false)\nstring nstr; // 给定数字的字符串形式 int n = nstr.size(); // 位数 int m = 1 \u0026lt;\u0026lt; 10; // 0 - 9 的mask vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(m, -1)); function\u0026lt;int(int, int, bool, bool)\u0026gt; dfs = [\u0026amp;](int index, int mask, bool isLimit, bool isNum) { // 到头 if (index == n) return ...; // 已缓存 if (!isLimit \u0026amp;\u0026amp; dp[index][mask] != -1) { return dp[index][mask]; } int ans = 0; // 是否可以跳过 if (!isNum) { ans += dfs(index + 1, mask, false, false); } // 确定枚举数字范围，最多[0, 9] int left = 1 - isNum; int right = isLimit ? nstr[index] - \u0026#39;0\u0026#39; : 9; for (int i = left; i \u0026lt;= right; ++i) { // 不在mask中 if (mask \u0026gt;\u0026gt; i \u0026amp; 1) continue; ans += dfs(index + 1, mask | (1 \u0026lt;\u0026lt; i), isLimit \u0026amp;\u0026amp; i == right, true); } // 缓存 if (!isLimit) { dp[index][mask] = ans; } return ans; }; ","date":"2024-11-10T00:00:00Z","permalink":"https://miyan.site/p/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","title":"常用算法模板"},{"content":"每次跑gitlab ci都需要pull一个镜像很费时间，则可以修改gitlab-runner的参数\n修改config.toml文件中的[[runners]] [runners.docker] pull_policy = \u0026ldquo;if-not-present\u0026rdquo;\n[[runners]] [runners.docker] pull_policy = \u0026#34;if-not-present\u0026#34; 参考：\nhttps://docs.gitlab.com/runner/executors/docker.html#how-pull-policies-work https://stackoverflow.com/questions/63043714/gitlab-runner-pulls-image-for-every-job ","date":"2024-09-02T00:00:00Z","permalink":"https://miyan.site/p/gitlab-ci-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E7%9A%84docker-image/","title":"[gitlab ci] 怎么使用本地的docker image"},{"content":"bat脚本如下，涉及到的函数主要是 netsh advfirewall firewall add rule 和 netsh advfirewall firewall delete rule\n需要注意的一个坑是program的路径不能存在斜杠/，需要使用\\，然而很多软件都会自动把路径生成为类似于C:/User/...这种形式，需要在脚本里转换一下\nrem Check if both program path and program name are provided as arguments if \u0026#34;%~1\u0026#34;==\u0026#34;\u0026#34; ( echo Usage: %0 program_path program_name echo Example: %0 \u0026#34;C:\\Path\\to\\your\\program.exe\u0026#34; YourProgramName exit /b 1 ) if \u0026#34;%~2\u0026#34;==\u0026#34;\u0026#34; ( echo Usage: %0 program_path program_name echo Example: %0 \u0026#34;C:\\Path\\to\\your\\program.exe\u0026#34; YourProgramName exit /b 1 ) set \u0026#34;programPath=%~1\u0026#34; set \u0026#34;programName=%~2\u0026#34; rem 替换斜杠为反斜杠 set \u0026#34;programPath=%programPath:/=\\%\u0026#34; rem Delete firewall rule netsh advfirewall firewall delete rule name=\u0026#34;%programName%(TCP)\u0026#34; netsh advfirewall firewall delete rule name=\u0026#34;%programName%(UDP)\u0026#34; rem Add firewall rule for TCP netsh advfirewall firewall add rule name=\u0026#34;%programName%(TCP)\u0026#34; dir=in program=\u0026#34;%programPath%\u0026#34; action=allow protocol=TCP rem Add firewall rule for UDP netsh advfirewall firewall add rule name=\u0026#34;%programName%(UDP)\u0026#34; dir=in program=\u0026#34;%programPath%\u0026#34; action=allow protocol=UDP echo Firewall rules for %programName% added successfully. ","date":"2024-03-06T00:00:00Z","permalink":"https://miyan.site/p/windows%E6%B7%BB%E5%8A%A0%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99/","title":"windows添加防火墙规则"},{"content":"外观 分享一下我实现的颜色编辑器，主要原因是Qt的QColorDialog功能较少没法满足需求，目前已经在zeno中使用了，由于zeno有自己的样式表，所以在zeno里长这样：\n类名 描述 ColorWheel 颜色选择器，用于选择颜色 GradientSlider 渐变滑块，带有渐变颜色 ColorSpinHSlider 带标签和旋钮的水平颜色滑块 ColorButton 颜色按钮，显示颜色并支持拖拽和释放颜色 ColorPalette 颜色调板，显示颜色列表并支持拖拽和释放 ColorPreview 颜色预览，显示当前和之前选择的颜色 ColorComboWidget 颜色组合切换器，用于切换颜色组合 ColorLineEdit 颜色名称文本框，显示颜色名称 ColorPicker 颜色拾取器，用于抓取屏幕颜色 功能预览（未配置样式表） srgb切换 颜色轮选色 颜色文字选色 屏幕取色，主要实现是截取当前的屏幕然后根据鼠标的位置设置颜色，支持多个屏幕（我自己只测试了2个屏幕） 颜色滑动条选色，RGB和HSV 颜色面板取色 颜色面板，可以把想要的颜色记录在这，持久化存储，即便关闭下一次打开也会自动加载 上一个/当前颜色切换，这个主要是类似于PS之类的软件，可以缓存一个颜色用来备选或者撤销 互补色取色，主要参考color-wheel 如何使用 github地址Qt-ColorEditor\n复制 ColorWidgets 文件夹(只包含两个文件: ColorEditor.h 和 ColorEditor.cpp) 到你的项目，记得添加到构建系统如cmake中.\n接口参照QColorDialog的方式：\n#include \u0026#34;ColorWidgets/ColorEditor.h\u0026#34; // ... // call here, you can find this in MainWindow.cpp auto btn = new ColorButton(this); btn-\u0026gt;setColor(Qt::blue); setCentralWidget(btn); connect(btn, \u0026amp;ColorButton::clicked, this, [this, btn](){ auto color = ColorEditor::getColor(btn-\u0026gt;color(), this, \u0026#34;\u0026#34;); btn-\u0026gt;setColor(color); }); 最后还得说一句，QColorDialog的功能确实有点少了，我在实现的时候参考了很多3D软件，如Houdini、Blender、Unity等，其中Houdini的功能最多，因此最终的形态也和Houdini类似了。\n","date":"2024-01-30T00:00:00Z","permalink":"https://miyan.site/p/qt-coloreditorqt%E9%A2%9C%E8%89%B2%E7%BC%96%E8%BE%91%E5%99%A8/","title":"Qt-ColorEditor，Qt颜色编辑器"},{"content":"作者：Scruel 链接：https://www.zhihu.com/question/34541107/answer/243592603 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n正好看到, 那就一行代码解决问题吧\nnet file 1\u0026gt;NUL 2\u0026gt;NUL || start \u0026#34;\u0026#34; mshta vbscript:CreateObject(\u0026#34;Shell.Application\u0026#34;).ShellExecute(\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c pushd \u0026#34;\u0026#34;%~dp0\u0026#34;\u0026#34; \u0026amp;\u0026amp; \u0026#34;\u0026#34;%~s0\u0026#34;\u0026#34; %*\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;runas\u0026#34;,0)(window.close) \u0026amp;\u0026amp; exit 如果VBScript 被砍掉，则可用 powershell 来执行，原理是一样的：\nnet file 1\u0026gt;NUL 2\u0026gt;NUL || powershell Start-Process -FilePath cmd.exe -ArgumentList \u0026#34;\u0026#34;\u0026#34;/c pushd %~dp0 \u0026amp;\u0026amp; %~s0 %*\u0026#34;\u0026#34;\u0026#34; -Verb RunAs \u0026amp;\u0026amp; exit 可支持：\n带空格的脚本路径 自动切换至脚本所在的路径 脚本参数传递 可隐藏窗口执行脚本（下文） 需要隐藏窗口执行的话，对于 mshta 版本，只需要改变 0 为 1 即可：\nnet file 1\u0026gt;NUL 2\u0026gt;NUL || start \u0026#34;\u0026#34; mshta vbscript:CreateObject(\u0026#34;Shell.Application\u0026#34;).ShellExecute(\u0026#34;cmd.exe\u0026#34;,\u0026#34;/c pushd \u0026#34;\u0026#34;%~dp0\u0026#34;\u0026#34; \u0026amp;\u0026amp; \u0026#34;\u0026#34;%~s0\u0026#34;\u0026#34; %*\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;runas\u0026#34;,1)(window.close) \u0026amp;\u0026amp; exit 以及 powershell 版本，简单增加 -WindowStyle Hidden 即可：\nnet file 1\u0026gt;NUL 2\u0026gt;NUL || powershell Start-Process -FilePath cmd.exe -ArgumentList \u0026#34;\u0026#34;\u0026#34;/c pushd %~dp0 \u0026amp;\u0026amp; %~s0 %*\u0026#34;\u0026#34;\u0026#34; -Verb RunAs -WindowStyle Hidden \u0026amp;\u0026amp; exit 解释一下：\n当前值 当前值含义 %~s0 脚本的绝对路径 %~dp0 脚本所在目录的绝对路径 runas 以管理员权限执行 使用 cmd.exe 来执行，是为了能让脚本在执行时，自动切换到其所在的路径，因为直接通过 ShellExecute执行，并不能做到自动切换目录。\n","date":"2023-12-25T00:00:00Z","permalink":"https://miyan.site/p/windows%E8%87%AA%E5%8A%A8%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8Cbat%E6%96%87%E4%BB%B6/","title":"windows自动以管理员身份运行bat文件"},{"content":"在给MetaBCI编写github ci时发现在不同的平台下依赖不尽相同，版本要求不尽相同，在这里记录下\n参考https://pip.pypa.io/en/stable/reference/requirement-specifiers/\n# --------------------------------- # System platform value # --------------------------------- # AIX \u0026#34;aix\u0026#34; # Linux \u0026#34;linux\u0026#34; # Windows \u0026#34;win32\u0026#34; # Windows/Cygwin \u0026#34;cygwin\u0026#34; # MacOS \u0026#34;darwin\u0026#34; # --------------------------------- atomac==1.1.0; sys_platform == \u0026#39;darwin\u0026#39; futures\u0026gt;=3.0.5; python_version \u0026lt; \u0026#39;3.0\u0026#39; futures\u0026gt;=3.0.5; python_version == \u0026#39;2.6\u0026#39; or python_version==\u0026#39;2.7\u0026#39; ","date":"2022-11-16T00:00:00Z","permalink":"https://miyan.site/p/python-requirements.txt-%E9%87%8C%E6%8C%87%E5%AE%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8Cpython%E7%89%88%E6%9C%AC/","title":"python requirements.txt 里指定操作系统和python版本"},{"content":" AList = [A()] * n, 此时AList里的所有元素具有相同id, 即是同一个对象，修改AList[0]相当于修改AList的所有元素 AList = [A() for i in range(n)], 此时AList里的所有元素都是不同的id, 即是不同的对象, 这样修改任意元素不会影响其他元素 ","date":"2022-10-26T00:00:00Z","permalink":"https://miyan.site/p/python-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84list/","title":"python 初始化一个固定大小的list"},{"content":"导出的坑 dynamic module does not define module export function 这是由于导出的包名不一致导致的，需要保证 cmake的project名称\nproject (\u0026#34;haha\u0026#34; LANGUAGES CXX) # \u0026lt;-- haha find_package (Python 3.8 EXACT COMPONENTS Interpreter Development REQUIRED) find_package(pybind11 REQUIRED) pybind11_add_module(${PROJECT_NAME} src/main.cpp) 与 main.cpp里的PYBIND11_MODULE\nPYBIND11_MODULE(haha, m) { // \u0026lt;-- haha m.doc() = \u0026#34;haha c++ wrapper\u0026#34;; } 名称一致\n回调函数 我们可以在cpp里定义一个回调函数，然后python定义一个函数传到c++里，从而从c++取到数据\n// c++ using PyCallback = std::function\u0026lt;void(pybind11::bytearray)\u0026gt;; class Haha { public: void setCallback(PyCallback\u0026amp; pyfn) { m_pyfn = pyfn; } void onDataAvaiable(char* buf, int len) { m_pyfn(pybind11::bytearray(buf, len)); } private: PyCallback m_pyfn; }; PYBIND11_MODULE(haha, m) { pybind11::class_\u0026lt;Haha\u0026gt;(m, \u0026#34;Haha\u0026#34;) .def(\u0026#34;setCallback\u0026#34;, \u0026amp;Haha::setCallback); } // python def fn(data): print(data) hahaInstance = m.Haha() hahaInstance .setCallback(fn) while True: // 阻塞保证hahaInstance一直运行，不断调用callback 报错：Some automatic conversions are optional and require extra headers to be included when compiling your pybind11 module 这是由于使用了c++的function但是导出的时候未#include \u0026lt;pybind11/functional.h\u0026gt;\n报错: DLL load failed while importing xxx 这是由于c++库引用了某个dll，但是没和pyd放到同一路径下，python import 的时候自然找不到对应的dll了\n执行python传入的回调函数时直接crash cpp里不能把PyCallback写成引用\nclass Haha { private: PyCallback\u0026amp; m_pyfn; // \u0026lt;-- 不能写引用 }; ","date":"2022-09-02T00:00:00Z","permalink":"https://miyan.site/p/pybind11%E4%BD%BF%E7%94%A82-%E7%BC%96%E5%86%99c-%E7%B1%BB%E5%B9%B6%E5%AF%BC%E5%87%BA%E4%B8%BApyd/","title":"pybind11使用(2) 编写C++类并导出为pyd"},{"content":"看似简单的配置流程 安装 : vcpkg install pybind11\n编写 cmake\nfind_package(pybind11 REQUIRED) pybind11_add_module(${PROJECT_NAME} src/main.cpp) 问题随之而来 [build] LINK : fatal error LNK1104: cannot open file \u0026lsquo;optimized.lib\u0026rsquo; 这个问题在老版vcpkg是存在的，在某一版本修复 而我的vcpkg好久没pull了，不幸的命中了这个问题，看来用vcpkg得及时更新\u0026hellip;\n无效的函数python_add_library 由于pybind11在python3.8导出的模块只能给对应的python3.8版本用，导致想用多个python版本跑行不通，因此得多个版本编译，cmake脚本应修改为:\nfind_package (Python 3.8 EXACT COMPONENTS Interpreter Development REQUIRED) find_package(pybind11 REQUIRED) pybind11_add_module(${PROJECT_NAME} src/main.cpp) 这里有个坑，如果写find_package (Python 3.8 EXACT REQUIRED)而不是find_package (Python 3.8 EXACT COMPONENTS Interpreter Development REQUIRED)就会提示找不到python_add_library\npython的版本管理 主要有两种方法：\n手动安装python版本 下载python并安装，注意要把路径添加到环境变量\nvcpkg的version特性 使用version特性需要开启vcpkg的mainfest模式 在CmakeLists.txt的同级目录编写vcpkg.json文件：\n{ \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;builtin-baseline\u0026#34;: \u0026#34;c0b6d35a67d2ad358a6ced92b7aad16a7bf17737\u0026#34;, \u0026#34;dependencies\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;python3\u0026#34;, \u0026#34;version\u0026gt;=\u0026#34;: \u0026#34;3.8.3\u0026#34; }, \u0026#34;pybind11\u0026#34; ], \u0026#34;overrides\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;python3\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;3.8.3\u0026#34; } ] } 终于可以愉快使用pybind11啦 ","date":"2022-09-01T00:00:00Z","permalink":"https://miyan.site/p/pybind11%E4%BD%BF%E7%94%A81-cmake--vcpkg-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/","title":"pybind11使用(1) cmake + vcpkg 环境配置以及一些坑"},{"content":"写法 opengl4.5新增了DSA(direct_state_access), 可以不用glBindBuffer()和glBindVertexArray()直接设置好VAO、VBO、IBO, 只需要draw之前bind即可\n新旧函数对比（左侧为新函数） glCreateBuffers = glGenBuffers + glBindBuffer(the initialization part) glNamedBufferData = glBufferData, 但是glNamedBufferData不需要指定target类型，只需要bufferid glVertexArrayVertexBuffer = glBindVertexArray + glBindBuffer, 把VBO绑定到VAO上 glVertexArrayElementBuffer = glBindVertexArray + glBindBuffer, 把IBO绑定到VAO上 glEnableVertexArrayAttrib = glBindVertexArray + glEnableVertexAttribArray, 不用bind VAO可以直接enable（这函数名有点难以区分\u0026hellip;\u0026hellip;） glVertexArrayAttribFormat + glVertexArrayAttribBinding = glVertexAttribPointer, opengl4.3开始加了 binding index 的概念，我们可以把VAO的某个属性与某个 binding index 关联起来，然后glVertexArrayVertexBuffer的时候把某个 binding index 关联的属性都绑定到VBO上 示例代码 // 顶点属性 struct vertex { vec3 loc; vec3 normal; vec2 texcoord; }; // 创建vao glCreateVertexArrays(1, \u0026amp;vao); // 无需绑定，直接进行下面的函数 // 启用属性 glEnableVertexArrayAttrib(vao, loc_attrib); glEnableVertexArrayAttrib(vao, normal_attrib); glEnableVertexArrayAttrib(vao, texcoord_attrib); // 设置格式 glVertexArrayAttribFormat(vao, loc_attrib, 3, GL_FLOAT, GL_FALSE, offsetof(vertex, loc)); glVertexArrayAttribFormat(vao, normal_attrib, 3, GL_FLOAT, GL_FALSE, offsetof(vertex, normal)); glVertexArrayAttribFormat(vao, texcoord_attrib, 2, GL_FLOAT, GL_FALSE, offsetof(vertex, texcoord)); // 把属性关联到bindingindex上 GLuint bindingindex = 0; glVertexArrayAttribBinding(vao, loc_attrib, bindingindex); glVertexArrayAttribBinding(vao, normal_attrib, bindingindex); glVertexArrayAttribBinding(vao, texcoord_attrib, bindingindex); // 创建vbo glCreateBuffers(1, \u0026amp;vbo); // 直接把vao上bindingindex关联的属性绑定到vbo上 glVertexArrayVertexBuffer(vao, bindingindex, vbo, 0, sizeof(vertex)); // 创建ibo glCreateBuffers(1, \u0026amp;ibo); // 绑定ibo到vao上 glVertexArrayElementBuffer(vao, ibo) // 绘制前仍需绑定vao glBindVertexArray(vao); glDrawArrays(...); 参考 opengl doc what-is-the-role-of-glbindvertexarrays-vs-glbindbuffer-and-what-is-their-relatio Guide-to-Modern-OpenGL-Functions\n","date":"2022-08-30T00:00:00Z","permalink":"https://miyan.site/p/opengl-4.5-%E7%9A%84-vaovboibo%E5%86%99%E6%B3%95/","title":"OpenGL 4.5+ 的 VAO、VBO、IBO写法"},{"content":"最近正在使用Qt的QOpenGLWidget来学习opengl，前期进展十分顺利，直到我遇到了framebuffer这一章节 framebuffer的大致使用方式如下：\n// 创建FBO unsigned int framebuffer; glGenFramebuffers(1, \u0026amp;framebuffer); glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); // create a color attachment texture unsigned int textureColorbuffer; glGenTextures(1, \u0026amp;textureColorbuffer); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0); // create a renderbuffer object for depth and stencil attachment (we won\u0026#39;t be sampling these) unsigned int rbo; glGenRenderbuffers(1, \u0026amp;rbo); glBindRenderbuffer(GL_RENDERBUFFER, rbo); glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT); // use a single renderbuffer object for both a depth AND stencil buffer. glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo); // now actually attach it // now that we actually created the framebuffer and added all attachments we want to check if it is actually complete now if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) cout \u0026lt;\u0026lt; \u0026#34;ERROR::FRAMEBUFFER:: Framebuffer is not complete!\u0026#34; \u0026lt;\u0026lt; endl; glBindFramebuffer(GL_FRAMEBUFFER, 0); // 第一处理阶段(Pass) glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 我们现在不使用模板缓冲 glEnable(GL_DEPTH_TEST); DrawScene(); // 第二处理阶段 glBindFramebuffer(GL_FRAMEBUFFER, 0); // 返回默认 glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); glBindVertexArray(quadVAO); glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, textureColorbuffer); glDrawArrays(GL_TRIANGLES, 0, 6); 程序很简单，但是当我运行之后，发现屏幕全白，即对应glClearColor(1.0f, 1.0f, 1.0f, 1.0f)，为了验证我这个猜想，我进行了以下步骤：\n屏幕全白是不是真的对应到glClearColor这个函数。修改清屏颜色，发现运行后的屏幕颜色确实和其一一对应。 有没有真的把三角形绘制上去。把glDrawArrays(GL_TRIANGLES, 0, 6)删除后，发现并不影响屏幕全白这一结果，因此问题应该出现在glClearColor(1.0f, 1.0f, 1.0f, 1.0f)之前。 删除第二处理阶段的这几行代码，发现屏幕变黑，对应glClearColor(0.1f, 0.1f, 0.1f, 1.0f)，再把glBindFramebuffer(GL_FRAMEBUFFER, framebuffer)注释掉，让物体不绘制在帧缓冲内，而是直接绘制到当前屏幕上，嘿，没问题！ 那……问题应该是出现在帧缓冲绑定上？我们是否真的绑定到了帧缓冲区呢？ stackoverflow搜索一波： OpenGL Qt : problem using framebuffers for bloom effect OpenGL does not render to screen by calling glBindFramebuffer(GL_FRAMEBUFFER,0) Easiest way for offscreen rendering with QOpenGLWidget\n果真是缓冲区绑定的问题！当我们执行glBindFramebuffer(GL_FRAMEBUFFER, 0)时，我们并没有返回到Qt默认的帧缓冲，应该先调用QOpenGLContext::defaultFramebufferObject()这个函数得到Qt默认的帧缓冲，\nCall this to get the default framebuffer object for the current surface. On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0. Thus, instead of calling glBindFramebuffer(0), you should call glBindFramebuffer(ctx-\u0026gt;defaultFramebufferObject()) if you want your application to work across different Qt platforms. If you use the glBindFramebuffer() in QOpenGLFunctions you do not have to worry about this, as it automatically binds the current context\u0026rsquo;s defaultFramebufferObject() when 0 is passed. Note: Widgets that render via framebuffer objects, like QOpenGLWidget and QQuickWidget, will override the value returned from this function when painting is active, because at that time the correct \u0026ldquo;default\u0026rdquo; framebuffer is the widget\u0026rsquo;s associated backing framebuffer, not the platform-specific one belonging to the top-level window\u0026rsquo;s surface. This ensures the expected behavior for this function and other classes relying on it (for example, QOpenGLFramebufferObject::bindDefault() or QOpenGLFramebufferObject::release()). See also QOpenGLFramebufferObject.\n即需要这么改： glBindFramebuffer(GL_FRAMEBUFFER, defaultFramebufferObject());\n修改完之后，终于把这个问题解决啦！\n当然，我们可以使用qt封装好的QOpenGLFramebufferObject类，这样代码更加简洁：\n// 创建FBO m_FBO = std::make_unique\u0026lt;QOpenGLFramebufferObject\u0026gt;(this-\u0026gt;size(), QOpenGLFramebufferObject::CombinedDepthStencil); // 第一处理阶段(Pass) m_FBO-\u0026gt;bind(); glClearColor(0.1f, 0.1f, 0.1f, 1.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 我们现在不使用模板缓冲 glEnable(GL_DEPTH_TEST); DrawScene(); // 第二处理阶段 m_FBO-\u0026gt;release(); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); screenShader.use(); glBindVertexArray(quadVAO); glDisable(GL_DEPTH_TEST); glBindTexture(GL_TEXTURE_2D, m_FBO-\u0026gt;texture(); glDrawArrays(GL_TRIANGLES, 0, 6); 我使用QOpenGLWidget学习opengl的代码放在github上了，欢迎访问~ miyanyan/learnopengl-qt\n","date":"2021-08-12T00:00:00Z","permalink":"https://miyan.site/p/qtglbindframebuffergl_framebuffer-0-%E5%AF%BC%E8%87%B4%E5%B1%8F%E5%B9%95%E7%A9%BA%E7%99%BD%E7%9A%84%E9%97%AE%E9%A2%98/","title":"【Qt】glBindFramebuffer(GL_FRAMEBUFFER, 0) 导致屏幕空白的问题"}]